{"version":3,"file":"textAnalysisClient.js","sourceRoot":"","sources":["../../src/textAnalysisClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AnalyzeActionName,\n  AnalyzeActionParameters,\n  AnalyzeBatchAction,\n  AnalyzeBatchPoller,\n  AnalyzeResult,\n  BeginAnalyzeBatchOptions,\n  RestoreAnalyzeBatchPollerOptions,\n  TextAnalysisClientOptions,\n  TextAnalysisOperationOptions,\n} from \"./models\";\nimport {\n  AnalyzeBatchActionUnion,\n  GeneratedClientOptionalParams,\n  LanguageDetectionInput,\n  TextDocumentInput,\n} from \"./generated/models\";\nimport { DEFAULT_COGNITIVE_SCOPE, SDK_VERSION } from \"./constants\";\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { TracingClient, createTracingClient } from \"@azure/core-tracing\";\nimport {\n  convertToLanguageDetectionInput,\n  convertToTextDocumentInput,\n  getOperationOptions,\n  isStringArray,\n} from \"./util\";\nimport {\n  createAnalyzeBatchLro,\n  createCreateAnalyzeBatchPollerLro,\n  createPollerWithCancellation,\n  createUpdateAnalyzeState,\n  getDocIDsFromState,\n  processAnalyzeResult,\n} from \"./lro\";\nimport { throwError, transformActionResult } from \"./transforms\";\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\nimport { createHttpPoller } from \"@azure/core-lro\";\nimport { logger } from \"./logger\";\nimport { textAnalyticsAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\n\n/**\n * A client for interacting with the text analysis features in Azure Cognitive\n * Language Service.\n *\n * The client needs the endpoint of a Language resource and an authentication\n * method such as an API key or AAD. The API key and endpoint can be found in\n * the Language resource page in the Azure portal. They will be located in the\n * resource's Keys and Endpoint page, under Resource Management.\n *\n * ### Examples for authentication:\n *\n * #### API Key\n *\n * ```js\n * import { TextAnalysisClient, AzureKeyCredential } from \"@azure/ai-language-text\";\n *\n * const endpoint = \"https://<resource name>.cognitiveservices.azure.com\";\n * const credential = new AzureKeyCredential(\"<api key>\");\n *\n * const client = new TextAnalysisClient(endpoint, credential);\n * ```\n *\n * #### Azure Active Directory\n *\n * See the [`@azure/identity`](https://npmjs.com/package/\\@azure/identity)\n * package for more information about authenticating with Azure Active Directory.\n *\n * ```js\n * import { TextAnalysisClient } from \"@azure/ai-language-text\";\n * import { DefaultAzureCredential } from \"@azure/identity\";\n *\n * const endpoint = \"https://<resource name>.cognitiveservices.azure.com\";\n * const credential = new DefaultAzureCredential();\n *\n * const client = new TextAnalysisClient(endpoint, credential);\n * ```\n */\nexport class TextAnalysisClient {\n  private readonly _client: GeneratedClient;\n  private readonly _tracing: TracingClient;\n  private readonly defaultCountryHint: string;\n  private readonly defaultLanguage: string;\n\n  /**\n   * Creates an instance of TextAnalysisClient with the endpoint of a Language\n   * resource and an authentication method such as an API key or AAD.\n   *\n   * The API key and endpoint can be found in the Language resource page in the\n   * Azure portal. They will be located in the resource's Keys and Endpoint page,\n   * under Resource Management.\n   *\n   * ### Example\n   *\n   * ```js\n   * import { TextAnalysisClient, AzureKeyCredential } from \"@azure/ai-language-text\";\n   *\n   * const endpoint = \"https://<resource name>.cognitiveservices.azure.com\";\n   * const credential = new AzureKeyCredential(\"<api key>\");\n   *\n   * const client = new TextAnalysisClient(endpoint, credential);\n   * ```\n   *\n   * @param endpointUrl - The URL to the endpoint of a Cognitive Language Service resource\n   * @param credential - Key credential to be used to authenticate requests to the service.\n   * @param options - Used to configure the TextAnalytics client.\n   */\n  constructor(endpointUrl: string, credential: KeyCredential, options?: TextAnalysisClientOptions);\n  /**\n   * Creates an instance of TextAnalysisClient with the endpoint of a Language\n   * resource and an authentication method such as an API key or AAD.\n   *\n   * The API key and endpoint can be found in the Language resource page in the\n   * Azure portal. They will be located in the resource's Keys and Endpoint page,\n   * under Resource Management.\n   *\n   * ### Example\n   *\n   * See the [`@azure/identity`](https://npmjs.com/package/\\@azure/identity)\n   * package for more information about authenticating with Azure Active Directory.\n   *\n   * ```js\n   * import { TextAnalysisClient } from \"@azure/ai-language-text\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * const endpoint = \"https://<resource name>.cognitiveservices.azure.com\";\n   * const credential = new DefaultAzureCredential();\n   *\n   * const client = new TextAnalysisClient(endpoint, credential);\n   * ```\n   *\n   * @param endpointUrl - The URL to the endpoint of a Cognitive Language Service resource\n   * @param credential - Token credential to be used to authenticate requests to the service.\n   * @param options - Used to configure the TextAnalytics client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential,\n    options?: TextAnalysisClientOptions\n  );\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: TextAnalysisClientOptions = {}\n  ) {\n    const {\n      defaultCountryHint = \"us\",\n      defaultLanguage = \"en\",\n      serviceVersion,\n      ...pipelineOptions\n    } = options;\n    this.defaultCountryHint = defaultCountryHint;\n    this.defaultLanguage = defaultLanguage;\n\n    const internalPipelineOptions: GeneratedClientOptionalParams = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          additionalAllowedHeaderNames: [\"x-ms-correlation-request-id\", \"x-ms-request-id\"],\n        },\n      },\n      apiVersion: serviceVersion,\n    };\n\n    this._client = new GeneratedClient(endpointUrl, internalPipelineOptions);\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE })\n      : textAnalyticsAzureKeyCredentialPolicy(credential);\n\n    this._client.pipeline.addPolicy(authPolicy);\n    this._tracing = createTracingClient({\n      packageName: \"@azure/ai-language-text\",\n      packageVersion: SDK_VERSION,\n      namespace: \"Microsoft.CognitiveServices\",\n    });\n  }\n\n  /**\n   * Runs a predictive model to determine the language that the passed-in\n   * input strings are written in, and returns, for each one, the detected\n   * language as well as a score indicating the model's confidence that the\n   * inferred language is correct.  Scores close to 1 indicate high certainty in\n   * the result.  120 languages are supported.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Language detection\n   *\n   * ```js\n   * const documents = [<input strings>];\n   * const countryHint = \"us\";\n   * const results = await client.analyze(\"LanguageDetection\", documents, countryHint);\n   *\n   * for (let i = 0; i < results.length; i++) {\n   *   const result = results[i];\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { name, confidenceScore, iso6391Name } = result.primaryLanguage;\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/language-detection/overview}\n   * for more information on language detection.\n   *\n   * @param actionName - the name of the action to be performed on the input\n   *   documents, see ${@link AnalyzeActionName}\n   * @param documents - the input documents to be analyzed\n   * @param options - optional action parameters and settings for the operation\n   *\n   * @returns an array of results where each element contains the primary language\n   *   for the corresponding input document.\n   */\n  public async analyze<ActionName extends \"LanguageDetection\">(\n    actionName: ActionName,\n    documents: LanguageDetectionInput[],\n    options?: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions\n  ): Promise<AnalyzeResult<ActionName>>;\n  /**\n   * Runs a predictive model to determine the language that the passed-in\n   * input strings are written in, and returns, for each one, the detected\n   * language as well as a score indicating the model's confidence that the\n   * inferred language is correct.  Scores close to 1 indicate high certainty in\n   * the result.  120 languages are supported.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Language detection\n   *\n   * ```js\n   * const documents = [<input strings>];\n   * const countryHint = \"us\";\n   * const results = await client.analyze(\"LanguageDetection\", documents, countryHint);\n   *\n   * for (const result of results) {\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { name, confidenceScore, iso6391Name } = result.primaryLanguage;\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/language-detection/overview}\n   * for more information on language detection.\n   *\n   * @param actionName - the name of the action to be performed on the input\n   *   documents, see ${@link AnalyzeActionName}\n   * @param documents - the input documents to be analyzed\n   * @param countryHint - Indicates the country of origin for all of\n   *   the input strings to assist the model in predicting the language they are\n   *   written in.  If unspecified, this value will be set to the default\n   *   country hint in `TextAnalysisClientOptions`. If set to an empty string,\n   *   or the string \"none\", the service will apply a model where the country is\n   *   explicitly unset. The same country hint is applied to all strings in the\n   *   input collection.\n   * @param options - optional action parameters and settings for the operation\n   *\n   * @returns an array of results where each element contains the primary language\n   *   for the corresponding input document.\n   */\n  public async analyze<ActionName extends \"LanguageDetection\">(\n    actionName: ActionName,\n    documents: string[],\n    countryHint?: string,\n    options?: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions\n  ): Promise<AnalyzeResult<ActionName>>;\n  /**\n   * Runs a predictive model to perform the action of choice on the input\n   * documents. See ${@link AnalyzeActionName} for a list of supported\n   * actions.\n   *\n   * The layout of each item in the results array depends on the action chosen.\n   * For example, each PIIEntityRecognition document result consists of both\n   * `entities` and `redactedText` where the former is a list of all Pii entities\n   * in the text and the latter is the original text after all such Pii entities\n   * have been redacted from it.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Opinion mining\n   *\n   * ```js\n   * const documents = [{\n   *  id: \"1\",\n   *  text: \"The food and service aren't the best\",\n   *  language: \"en\"\n   * }];\n   * const results = await client.analyze(\"SentimentAnalysis\", documents, {\n   *   includeOpinionMining: true,\n   * });\n   *\n   * for (const result of results) {\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { sentiment, confidenceScores, sentences } = result;\n   *     for (const { sentiment, confidenceScores, opinions } of sentences) {\n   *       for (const { target, assessments } of opinions) {\n   *         const { text, sentiment, confidenceScores } = target;\n   *         for (const { text, sentiment } of assessments) {\n   *           // Do something\n   *         }\n   *       }\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/sentiment-opinion-mining/overview}\n   * for more information on opinion mining.\n   *\n   * #### Personally identifiable information\n   *\n   * ```js\n   * const documents = [<input documents>];\n   * const categoriesFilter = [KnownPiiCategory.USSocialSecurityNumber];\n   * const domainFilter = KnownPiiDomain.Phi;\n   * const results = await client.analyze(\"PiiEntityRecognition\", documents, {\n   *   domainFilter, categoriesFilter\n   * });\n   *\n   * for (const result of results) {\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { entities, redactedText } = result;\n   *     for (const { text, category, confidenceScore, length, offset } of entities) {\n   *       // Do something\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/personally-identifiable-information/overview}\n   * for more information on personally identifiable information.\n   *\n   * @param actionName - the name of the action to be performed on the input\n   *   documents, see ${@link AnalyzeActionName}\n   * @param documents - the input documents to be analyzed\n   * @param options - optional action parameters and settings for the operation\n   *\n   * @returns an array of results corresponding to the input documents\n   */\n  public async analyze<ActionName extends AnalyzeActionName = AnalyzeActionName>(\n    actionName: ActionName,\n    documents: TextDocumentInput[],\n    options?: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions\n  ): Promise<AnalyzeResult<ActionName>>;\n\n  /**\n   * Runs a predictive model to perform the action of choice on the input\n   * strings. See ${@link AnalyzeActionName} for a list of supported\n   * actions.\n   *\n   * The layout of each item in the results array depends on the action chosen.\n   * For example, each PIIEntityRecognition document result consists of both\n   * `entities` and `redactedText` where the former is a list of all Pii entities\n   * in the text and the latter is the original text after all such Pii entities\n   * have been redacted from it.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Opinion mining\n   *\n   * ```js\n   * const documents = [\"The food and service aren't the best\"];\n   * const results = await client.analyze(\"SentimentAnalysis\", documents, {\n   *   includeOpinionMining: true,\n   * });\n   *\n   * for (const result of results) {\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { sentiment, confidenceScores, sentences } = result;\n   *     for (const { sentiment, confidenceScores, opinions } of sentences) {\n   *       for (const { target, assessments } of opinions) {\n   *         const { text, sentiment, confidenceScores } = target;\n   *         for (const { text, sentiment } of assessments) {\n   *           // Do something\n   *         }\n   *       }\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/sentiment-opinion-mining/overview}\n   * for more information on opinion mining.\n   *\n   * #### Personally identifiable information\n   *\n   * ```js\n   * const documents = [<input strings>];\n   * const languageCode = \"en\";\n   * const categoriesFilter = [KnownPiiCategory.USSocialSecurityNumber];\n   * const domainFilter = KnownPiiDomain.Phi;\n   * const results = await client.analyze(\"PiiEntityRecognition\", documents, languageCode, {\n   *   domainFilter, categoriesFilter\n   * });\n   *\n   * for (const result of results) {\n   *   if (result.error) {\n   *     // a document has an error instead of results\n   *   } else {\n   *     const { entities, redactedText } = result;\n   *     for (const { text, category, confidenceScore, length, offset } of entities) {\n   *       // Do something\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/personally-identifiable-information/overview}\n   * for more information on personally identifiable information.\n   *\n   * @param actionName - the name of the action to be performed on the input\n   *   documents, see ${@link AnalyzeActionName}\n   * @param documents - the input documents to be analyzed\n   * @param languageCode - the code of the language that all the input strings are\n   *    written in. If unspecified, this value will be set to the default\n   *    language in `TextAnalysisClientOptions`. If set to an empty string,\n   *    the service will apply a model where the language is explicitly set to\n   *    \"None\". Language support varies per action, for example, more information\n   *    about the languages supported for Entity Recognition actions can be\n   *    found in {@link https://docs.microsoft.com//azure/cognitive-services/language-service/named-entity-recognition/language-support}.\n   *    If set to \"auto\", the service will automatically infer the language from\n   *    the input text.\n   * @param options - optional action parameters and settings for the operation\n   *\n   * @returns an array of results corresponding to the input documents\n   */\n  public async analyze<ActionName extends AnalyzeActionName = AnalyzeActionName>(\n    actionName: ActionName,\n    documents: string[],\n    languageCode?: string,\n    options?: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions\n  ): Promise<AnalyzeResult<ActionName>>;\n  // implementation\n  public async analyze<ActionName extends AnalyzeActionName = AnalyzeActionName>(\n    actionName: ActionName,\n    documents: string[] | LanguageDetectionInput[] | TextDocumentInput[],\n    languageOrCountryHintOrOptions?:\n      | string\n      | (AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions),\n    options?: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions\n  ): Promise<AnalyzeResult<ActionName>> {\n    let realOptions: AnalyzeActionParameters<ActionName> & TextAnalysisOperationOptions;\n\n    if (documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    let realInputs: LanguageDetectionInput[] | TextDocumentInput[];\n    if (isStringArray(documents)) {\n      if (actionName === \"LanguageDetection\") {\n        realInputs = convertToLanguageDetectionInput(\n          documents,\n          typeof languageOrCountryHintOrOptions === \"string\"\n            ? languageOrCountryHintOrOptions\n            : this.defaultCountryHint\n        );\n      } else {\n        realInputs = convertToTextDocumentInput(\n          documents,\n          typeof languageOrCountryHintOrOptions === \"string\"\n            ? languageOrCountryHintOrOptions\n            : this.defaultLanguage\n        );\n      }\n      realOptions = options || ({} as any);\n    } else {\n      realInputs = documents;\n      realOptions =\n        (languageOrCountryHintOrOptions as AnalyzeActionParameters<ActionName> &\n          TextAnalysisOperationOptions) || {};\n    }\n    const { options: operationOptions, rest: action } = getOperationOptions(realOptions);\n    return this._tracing.withSpan(\n      \"TextAnalysisClient.analyze\",\n      operationOptions,\n      async (updatedOptions: TextAnalysisOperationOptions) =>\n        throwError(\n          this._client\n            .analyze(\n              {\n                kind: actionName,\n                analysisInput: {\n                  documents: realInputs,\n                },\n                parameters: action,\n              } as any,\n              updatedOptions\n            )\n            .then(\n              (result) =>\n                transformActionResult(\n                  actionName,\n                  realInputs.map(({ id }) => id),\n                  result\n                ) as AnalyzeResult<ActionName>\n            )\n        )\n    );\n  }\n\n  /**\n   * Performs an array (batch) of actions on the input documents. Each action has\n   * a `kind` field that specifies the nature of the action. See ${@link AnalyzeBatchActionNames}\n   * for a list of supported actions. In addition to `kind`, actions could also\n   * have other parameters such as `disableServiceLogs` and `modelVersion`.\n   *\n   * The results array contains the results for those input actions where each\n   * item also has a `kind` field that specifies the type of the results.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Key phrase extraction and Pii entity recognition\n   *\n   * ```js\n   * const poller = await client.beginAnalyzeBatch(\n   *  [{ kind: \"KeyPhraseExtraction\" }, { kind: \"PiiEntityRecognition\" }],\n   *  documents\n   * );\n   * const actionResults = await poller.pollUntilDone();\n   *\n   * for await (const actionResult of actionResults) {\n   *  if (actionResult.error) {\n   *    throw new Error(`Unexpected error`);\n   *  }\n   *  switch (actionResult.kind) {\n   *    case \"KeyPhraseExtraction\": {\n   *      for (const doc of actionResult.results) {\n   *        // do something\n   *      }\n   *      break;\n   *    }\n   *    case \"PiiEntityRecognition\": {\n   *      for (const doc of actionResult.results) {\n   *        // do something\n   *      }\n   *      break;\n   *    }\n   *  }\n   * }\n   * ```\n   *\n   * @param actions - an array of actions that will be run on the input documents\n   * @param documents - the input documents to be analyzed\n   * @param languageCode - the code of the language that all the input strings are\n   *    written in. If unspecified, this value will be set to the default\n   *    language in `TextAnalysisClientOptions`. If set to an empty string,\n   *    the service will apply a model where the language is explicitly set to\n   *    \"None\". Language support varies per action, for example, more information\n   *    about the languages supported for Entity Recognition actions can be\n   *    found in {@link https://docs.microsoft.com//azure/cognitive-services/language-service/named-entity-recognition/language-support}.\n   *    If set to \"auto\", the service will automatically infer the language from\n   *    the input text.\n   * @param options - optional settings for the operation\n   *\n   * @returns an array of results corresponding to the input actions\n   */\n  async beginAnalyzeBatch(\n    actions: AnalyzeBatchAction[],\n    documents: string[],\n    languageCode?: string,\n    options?: BeginAnalyzeBatchOptions\n  ): Promise<AnalyzeBatchPoller>;\n  /**\n   * Performs an array (batch) of actions on the input documents. Each action has\n   * a `kind` field that specifies the nature of the action. See ${@link AnalyzeBatchActionNames}\n   * for a list of supported actions. In addition to `kind`, actions could also\n   * have other parameters such as `disableServiceLogs` and `modelVersion`.\n   *\n   * The results array contains the results for those input actions where each\n   * item also has a `kind` field that specifies the type of the results.\n   *\n   * See {@link https://docs.microsoft.com//azure/cognitive-services/language-service/concepts/data-limits}\n   * for data limits.\n   *\n   * ### Examples\n   *\n   * #### Keyphrase extraction and Pii entity recognition\n   *\n   * ```js\n   * const poller = await client.beginAnalyzeBatch(\n   *  [{ kind: \"KeyPhraseExtraction\" }, { kind: \"PiiEntityRecognition\" }],\n   *  documents\n   * );\n   * const actionResults = await poller.pollUntilDone();\n   *\n   * for await (const actionResult of actionResults) {\n   *  if (actionResult.error) {\n   *    throw new Error(`Unexpected error`);\n   *  }\n   *  switch (actionResult.kind) {\n   *    case \"KeyPhraseExtraction\": {\n   *      for (const doc of actionResult.results) {\n   *        // do something\n   *      }\n   *      break;\n   *    }\n   *    case \"PiiEntityRecognition\": {\n   *      for (const doc of actionResult.results) {\n   *        // do something\n   *      }\n   *      break;\n   *    }\n   *  }\n   * }\n   * ```\n   *\n   * @param actions - an array of actions that will be run on the input documents\n   * @param documents - the input documents to be analyzed\n   * @param options - optional settings for the operation\n   *\n   * @returns an array of results corresponding to the input actions\n   */\n  async beginAnalyzeBatch(\n    actions: AnalyzeBatchAction[],\n    documents: TextDocumentInput[],\n    options?: BeginAnalyzeBatchOptions\n  ): Promise<AnalyzeBatchPoller>;\n  // implementation\n  async beginAnalyzeBatch(\n    actions: AnalyzeBatchAction[],\n    documents: TextDocumentInput[] | string[],\n    languageOrOptions?: BeginAnalyzeBatchOptions | string,\n    options: BeginAnalyzeBatchOptions = {}\n  ): Promise<AnalyzeBatchPoller> {\n    let realOptions: BeginAnalyzeBatchOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const languageCode = (languageOrOptions as string) ?? this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, languageCode);\n      realOptions = options;\n    } else {\n      realInputs = documents;\n      realOptions = languageOrOptions as BeginAnalyzeBatchOptions;\n    }\n    const realActions = actions.map(\n      ({ kind, actionName, ...rest }): AnalyzeBatchActionUnion & { parameters: unknown } => ({\n        kind,\n        actionName,\n        parameters: rest,\n      })\n    );\n    const { includeStatistics, updateIntervalInMs, displayName, ...rest } = realOptions;\n    const lro = createAnalyzeBatchLro({\n      client: this._client,\n      commonOptions: rest,\n      documents: realInputs,\n      initialRequestOptions: { displayName },\n      pollRequestOptions: { includeStatistics },\n      tasks: realActions,\n      tracing: this._tracing,\n    });\n\n    const docIds = realInputs.map(({ id }) => id);\n\n    const state = { continuationToken: \"\" };\n\n    const poller = await createHttpPoller(lro, {\n      intervalInMs: updateIntervalInMs,\n      processResult: processAnalyzeResult({\n        client: this._client,\n        tracing: this._tracing,\n        docIds,\n        opOptions: { ...rest, includeStatistics },\n        state,\n      }),\n      updateState: createUpdateAnalyzeState(docIds),\n      withOperationLocation(operationLocation: string) {\n        state.continuationToken = operationLocation;\n      },\n    });\n\n    await poller.poll();\n    const id = poller.getOperationState().id;\n    return createPollerWithCancellation({\n      id,\n      client: this._client,\n      options,\n      poller,\n      tracing: this._tracing,\n    });\n  }\n\n  /**\n   * Creates a poller from the serialized state of another poller. This can be\n   * useful when you want to create pollers on a different host or a poller\n   * needs to be constructed after the original one is not in scope.\n   *\n   * @param serializedState - the serialized state of another poller. It is the\n   *                          result of `poller.toString()`\n   * @param options - optional settings for the operation\n   *\n   * # Example\n   *\n   * `client.beginAnalyzeBatch` returns a promise that will resolve to a poller.\n   * The state of the poller can be serialized and used to create another as follows:\n   *\n   * ```js\n   * const serializedState = poller.toString();\n   * const rehydratedPoller = await client.createAnalyzeBatchPoller(serializedState);\n   * const actionResults = await rehydratedPoller.pollUntilDone();\n   * ```\n   */\n  async restoreAnalyzeBatchPoller(\n    serializedState: string,\n    options?: RestoreAnalyzeBatchPollerOptions\n  ): Promise<AnalyzeBatchPoller>;\n  // implementation\n  async restoreAnalyzeBatchPoller(\n    serializedState: string,\n    options: RestoreAnalyzeBatchPollerOptions = {}\n  ): Promise<AnalyzeBatchPoller> {\n    const { includeStatistics, updateIntervalInMs, ...rest } = options;\n    const docIds = getDocIDsFromState(serializedState);\n    const lro = createCreateAnalyzeBatchPollerLro({\n      client: this._client,\n      options: { ...rest, includeStatistics },\n      tracing: this._tracing,\n    });\n\n    const state = { continuationToken: \"\" };\n\n    const poller = await createHttpPoller(lro, {\n      intervalInMs: updateIntervalInMs,\n      restoreFrom: serializedState,\n      processResult: processAnalyzeResult({\n        client: this._client,\n        tracing: this._tracing,\n        docIds,\n        opOptions: { ...rest, includeStatistics },\n        state,\n      }),\n      updateState: createUpdateAnalyzeState(),\n      withOperationLocation(operationLocation: string) {\n        state.continuationToken = operationLocation;\n      },\n    });\n\n    await poller.poll();\n    const id = poller.getOperationState().id;\n    return createPollerWithCancellation({\n      id,\n      client: this._client,\n      options,\n      poller,\n      tracing: this._tracing,\n    });\n  }\n}\n"]}