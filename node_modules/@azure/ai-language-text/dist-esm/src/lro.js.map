{"version":3,"file":"lro.js","sourceRoot":"","sources":["../../src/lro.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,KAAK,OAAO,MAAM,4BAA4B,CAAC;AACtD,OAAO,KAAK,UAAU,MAAM,+BAA+B,CAAC;AAc5D,OAAO,EAIL,gBAAgB,GACjB,MAAM,oBAAoB,CAAC;AAE5B,OAAO,EAAe,qBAAqB,EAAE,MAAM,oBAAoB,CAAC;AACxE,OAAO,EAAE,UAAU,EAAE,4BAA4B,EAAE,MAAM,cAAc,CAAC;AAGxE,OAAO,EAAE,UAAU,EAAE,MAAM,aAAa,CAAC;AACzC,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;AAEhE,MAAM,sBAAsB,GAAkB;IAC5C,UAAU,EAAE,KAAK;IACjB,SAAS,EAAE;QACT,GAAG,EAAE;YACH,UAAU,EAAE,OAAO,CAAC,mBAAmB;SACxC;QACD,OAAO,EAAE;YACP,UAAU,EAAE,OAAO,CAAC,aAAa;SAClC;KACF;IACD,gBAAgB,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC;IACrC,eAAe,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,iBAAiB,CAAC;IAChF,UAAU;CACX,CAAC;AAEF,SAAS,aAAa,CACpB,OAAiB,EACjB,EAAmF;IAEnF,uCACK,OAAO,KACV,UAAU,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE;;YAC3C,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;YACjC,MAAA,OAAO,CAAC,UAAU,wDAAG,WAAW,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;QACrD,CAAC,IACD;AACJ,CAAC;AAED,SAAS,aAAa,CAAC,WAAkC;IACvD,MAAM,UAAU,GAAG,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACxD,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KACrD;AACH,CAAC;AAED,KAAK,UAAU,cAAc,CAC3B,WAAsD,EACtD,OAAiB;IAEjB,IAAI,WAAkC,CAAC;IACvC,MAAM,YAAY,GAAG,MAAM,WAAW,CACpC,aAAa,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE,EAAE;QAClC,WAAW,GAAG,QAAQ,CAAC;IACzB,CAAC,CAAC,CACH,CAAC;IACF,OAAO;QACL,YAAY;QACZ,WAAW,EAAE;YACX,UAAU,EAAE,WAAY,CAAC,MAAM;YAC/B,OAAO,EAAE,WAAY,CAAC,OAAO,CAAC,MAAM,EAAE;YACtC,IAAI,EAAE,WAAY,CAAC,UAAU;SAC9B;KACF,CAAC;AACJ,CAAC;AAED,KAAK,UAAU,WAAW,CAAoC,QAQ7D;IACC,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,GAAG,KAAK,EAAE,GAAG,QAAQ,CAAC;IACzF,OAAO,OAAO,CAAC,QAAQ,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,YAAsB,EAAE,EAAE,CAC3E,UAAU,CACR,cAAc,CACZ,CAAC,OAAO,EAAE,EAAE,CACV,MAAM,CAAC,oBAAoB,CACzB,EAAE,OAAO,EAAE,kCAEN,IAAI,KACP,IAAI;QACJ,UAAU,IAEb,EACH,YAAY,CACb,CACF,CACF,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,SAAS,qBAAqB,CAAoC,QAKjE;IACC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC;IACvD,OAAO,KAAK,EAAE,IAAY,EAAiC,EAAE;QAC3D,OAAO,UAAU,CACf,WAAW,CAAC;YACV,MAAM;YACN,SAAS,EAAE,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE;gBAChD,MAAM,YAAY,GAAG,QAAwC,CAAC;gBAC9D,IAAI,YAAY,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,oBAAoB,EAAE;oBAC9D,YAAY,CAAC,MAAM,GAAG,WAAW,CAAC;iBACnC;YACH,CAAC,CAAC;YACF,IAAI;YACJ,OAAO;YACP,IAAI,EAAE,sBAAsB;YAC5B,OAAO;SACR,CAAC,CACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,qBAAqB,CAAC,QAYrC;IACC,MAAM,EACJ,MAAM,EACN,aAAa,EACb,SAAS,EACT,qBAAqB,EACrB,kBAAkB,EAClB,KAAK,EACL,OAAO,GACR,GAAG,QAAQ,CAAC;IACb,OAAO;QACL,KAAK,CAAC,kBAAkB;YACtB,OAAO,OAAO,CAAC,QAAQ,CACrB,GAAG,UAAU,oBAAoB,EACjC,aAAa,iCAEN,aAAa,GACb,qBAAqB,GAE1B,aAAa,CACd,EACD,KAAK,EAAE,YAAY,EAAE,EAAE,CACrB,UAAU,CACR,cAAc,CACZ,CAAC,YAAY,EAAE,EAAE,CACf,MAAM,CAAC,YAAY,CACjB;gBACE,KAAK;gBACL,aAAa,EAAE;oBACb,SAAS;iBACV;gBACD,WAAW,EAAE,qBAAqB,CAAC,WAAW;aAC/C,EACD,YAAY,CACb,EACH,YAAY,CACb,CACF,CACJ,CAAC;QACJ,CAAC;QACD,eAAe,EAAE,qBAAqB,CAAC;YACrC,MAAM;YACN,OAAO,kCAAO,aAAa,GAAK,kBAAkB,CAAE;YACpD,OAAO,EAAE,GAAG,UAAU,oBAAoB;YAC1C,OAAO;SACR,CAAC;KACH,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,kBAAkB,CAAC,eAAuB;IACxD,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC;QACrD,OAAO,MAAM,CAAC;KACf;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,CAAC,KAAK,CACV,0FAA0F,CAC3F,CAAC;QACF,OAAO,EAAE,CAAC;KACX;AACH,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,iCAAiC,CAAoC,QAIpF;IACC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC;IAC9C,OAAO;QACL,KAAK,CAAC,kBAAkB;YACtB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;QACvD,CAAC;QACD,eAAe,EAAE,qBAAqB,CAAC;YACrC,MAAM;YACN,OAAO;YACP,OAAO,EAAE,GAAG,UAAU,oBAAoB;YAC1C,OAAO;SACR,CAAC;KACH,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,oBAAoB,CAAC,OAMpC;IACC,OAAO,GAA4B,EAAE;QACnC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC;QAC9D,MAAM,OAAO,GAAG,KAAK,CAAC,iBAAiB,CAAC;QACxC,MAAM,WAAW,GAAsC;YACrD,aAAa,EAAE,OAAO;YACtB,OAAO,EAAE,KAAK,EAAE,QAAgB,EAAE,WAAoB,EAAE,EAAE;gBACxD,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC;oBACjC,MAAM;oBACN,IAAI,EAAE,sBAAsB;oBAC5B,OAAO,EAAE,GAAG,UAAU,oBAAoB;oBAC1C,qEAAqE;oBACrE,0BAA0B;oBAC1B,SAAS,EAAE,WAAW,CAAC,CAAC,iCAAM,SAAS,KAAE,GAAG,EAAE,WAAW,IAAG,CAAC,CAAC,SAAS;oBACvE,IAAI,EAAE,QAAQ;oBACd,OAAO;iBACR,CAAC,CAAC;gBACH,MAAM,YAAY,GAAG,QAAQ,CAAC,YAA4C,CAAC;gBAC3E,OAAO;oBACL,IAAI,EAAE,4BAA4B,CAAC,MAAM,EAAE,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,MAAM,CAAC;oBACzF,YAAY,EAAE,YAAY,CAAC,QAAQ;iBACpC,CAAC;YACJ,CAAC;SACF,CAAC;QACF,OAAO,qBAAqB,CAAC,WAAW,CAAC,CAAC;IAC5C,CAAC,CAAC;AACJ,CAAC;AAMD;;GAEG;AACH,MAAM,UAAU,wBAAwB,CAAC,MAAiB;IACxD,OAAO,CAAC,KAAiC,EAAE,YAAyB,EAAQ,EAAE;QAC5E,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE,kBAAkB,EAAE,GACpF,YAAY,CAAC,YAA6E,CAAC;QAC7F,MAAM,YAAY,GAAG,KAEpB,CAAC;QACF,YAAY,CAAC,SAAS,GAAG,SAAS,CAAC;QACnC,8DAA8D;QAC9D,YAAY,CAAC,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,kBAAkB,CAAC,CAAC;QACjF,YAAY,CAAC,SAAS,GAAG,SAAS,CAAC;QACnC,YAAY,CAAC,WAAW,GAAG,WAAW,CAAC;QACvC,YAAY,CAAC,EAAE,GAAG,EAAE,CAAC;QACrB,YAAY,CAAC,oBAAoB,GAAG,KAAK,CAAC,SAAS,CAAC;QACpD,YAAY,CAAC,iBAAiB,GAAG,KAAK,CAAC,MAAM,CAAC;QAC9C,YAAY,CAAC,qBAAqB,GAAG,KAAK,CAAC,UAAU,CAAC;QACtD,IAAI,YAAY,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,SAAS,EAAE;YAC7D,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;SAC9B;IACH,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,4BAA4B,CAAC,QAM5C;IACC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC;IAC1D,uCACK,MAAM,KACT,uBAAuB,EAAE,KAAK,IAAI,EAAE;YAClC,MAAM,OAAO,CAAC,QAAQ,CAAC,GAAG,UAAU,oBAAoB,EAAE,OAAO,EAAE,KAAK,EAAE,YAAY,EAAE,EAAE,CACxF,UAAU,CACR,cAAc,CACZ,CAAC,YAAY,EAAE,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE,EAAE,YAAY,CAAC,EAChE,YAAY,CACb,CACF,CACF,CAAC;QACJ,CAAC,IACD;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as Mappers from \"./generated/models/mappers\";\nimport * as Parameters from \"./generated/models/parameters\";\nimport {\n  AnalyzeBatchActionUnion,\n  AnalyzeTextJobStatusOptionalParams,\n  AnalyzeTextJobStatusResponse,\n  GeneratedClient,\n  TextDocumentInput,\n} from \"./generated\";\nimport {\n  AnalyzeBatchOperationState,\n  AnalyzeBatchResult,\n  PagedAnalyzeBatchResult,\n  PollerLike,\n} from \"./models\";\nimport {\n  FullOperationResponse,\n  OperationOptions,\n  OperationSpec,\n  createSerializer,\n} from \"@azure/core-client\";\nimport { LongRunningOperation, LroResponse, SimplePollerLike } from \"@azure/core-lro\";\nimport { PagedResult, getPagedAsyncIterator } from \"@azure/core-paging\";\nimport { throwError, transformAnalyzeBatchResults } from \"./transforms\";\nimport { HttpMethods } from \"@azure/core-rest-pipeline\";\nimport { TracingClient } from \"@azure/core-tracing\";\nimport { clientName } from \"./constants\";\nimport { logger } from \"./logger\";\n\nconst serializer = createSerializer(Mappers, /* isXml */ false);\n\nconst jobStatusOperationSpec: OperationSpec = {\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeTextJobState,\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse,\n    },\n  },\n  headerParameters: [Parameters.accept],\n  queryParameters: [Parameters.top, Parameters.skip, Parameters.includeStatistics],\n  serializer,\n};\n\nfunction addOnResponse<TOptions extends OperationOptions>(\n  options: TOptions,\n  cb: (rawResponse: FullOperationResponse, response: unknown, error: unknown) => void\n): TOptions {\n  return {\n    ...options,\n    onResponse: (rawResponse, response, error) => {\n      cb(rawResponse, response, error);\n      options.onResponse?.(rawResponse, response, error);\n    },\n  };\n}\n\nfunction logWarnHeader(rawResponse: FullOperationResponse) {\n  const warnHeader = rawResponse.headers.get(\"warn-text\");\n  if (warnHeader) {\n    warnHeader.split(\";\").map((x) => logger.warning(x));\n  }\n}\n\nasync function getRawResponse<TOptions extends OperationOptions, TResponse>(\n  getResponse: (options: TOptions) => Promise<TResponse>,\n  options: TOptions\n): Promise<LroResponse<TResponse>> {\n  let rawResponse: FullOperationResponse;\n  const flatResponse = await getResponse(\n    addOnResponse(options, (response) => {\n      rawResponse = response;\n    })\n  );\n  return {\n    flatResponse,\n    rawResponse: {\n      statusCode: rawResponse!.status,\n      headers: rawResponse!.headers.toJSON(),\n      body: rawResponse!.parsedBody,\n    },\n  };\n}\n\nasync function sendRequest<TOptions extends OperationOptions>(settings: {\n  client: GeneratedClient;\n  tracing: TracingClient;\n  spec: OperationSpec;\n  spanStr: string;\n  opOptions: TOptions;\n  path: string;\n  httpMethod?: HttpMethods;\n}): Promise<LroResponse<unknown>> {\n  const { client, opOptions, path, spanStr, spec, tracing, httpMethod = \"GET\" } = settings;\n  return tracing.withSpan(spanStr, opOptions, async (finalOptions: TOptions) =>\n    throwError(\n      getRawResponse(\n        (options) =>\n          client.sendOperationRequest(\n            { options },\n            {\n              ...spec,\n              path,\n              httpMethod,\n            }\n          ),\n        finalOptions\n      )\n    )\n  );\n}\n\n/**\n * @internal\n */\nfunction createSendPollRequest<TOptions extends OperationOptions>(settings: {\n  client: GeneratedClient;\n  tracing: TracingClient;\n  options: TOptions;\n  spanStr: string;\n}): (path: string) => Promise<LroResponse<unknown>> {\n  const { client, options, tracing, spanStr } = settings;\n  return async (path: string): Promise<LroResponse<unknown>> => {\n    return throwError(\n      sendRequest({\n        client,\n        opOptions: addOnResponse(options, (_, response) => {\n          const castResponse = response as AnalyzeTextJobStatusResponse;\n          if (castResponse.status.toLowerCase() === \"partiallysucceeded\") {\n            castResponse.status = \"succeeded\";\n          }\n        }),\n        path,\n        spanStr,\n        spec: jobStatusOperationSpec,\n        tracing,\n      })\n    );\n  };\n}\n\n/**\n * @internal\n */\nexport function createAnalyzeBatchLro(settings: {\n  client: GeneratedClient;\n  tracing: TracingClient;\n  commonOptions: OperationOptions;\n  initialRequestOptions: {\n    displayName?: string;\n  };\n  pollRequestOptions: {\n    includeStatistics?: boolean;\n  };\n  documents: TextDocumentInput[];\n  tasks: AnalyzeBatchActionUnion[];\n}): LongRunningOperation {\n  const {\n    client,\n    commonOptions,\n    documents,\n    initialRequestOptions,\n    pollRequestOptions,\n    tasks,\n    tracing,\n  } = settings;\n  return {\n    async sendInitialRequest(): Promise<LroResponse<unknown>> {\n      return tracing.withSpan(\n        `${clientName}.beginAnalyzeBatch`,\n        addOnResponse(\n          {\n            ...commonOptions,\n            ...initialRequestOptions,\n          },\n          logWarnHeader\n        ),\n        async (finalOptions) =>\n          throwError(\n            getRawResponse(\n              (paramOptions) =>\n                client.analyzeBatch(\n                  {\n                    tasks,\n                    analysisInput: {\n                      documents,\n                    },\n                    displayName: initialRequestOptions.displayName,\n                  },\n                  paramOptions\n                ),\n              finalOptions\n            )\n          )\n      );\n    },\n    sendPollRequest: createSendPollRequest({\n      client,\n      options: { ...commonOptions, ...pollRequestOptions },\n      spanStr: `${clientName}.beginAnalyzeBatch`,\n      tracing,\n    }),\n  };\n}\n\n/**\n * @internal\n */\nexport function getDocIDsFromState(serializedState: string): string[] {\n  try {\n    const { docIds } = JSON.parse(serializedState).state;\n    return docIds;\n  } catch (e) {\n    logger.error(\n      `Document IDs are not found in the LRO's state. The results may not be ordered correctly.`\n    );\n    return [];\n  }\n}\n\n/**\n * @internal\n */\nexport function createCreateAnalyzeBatchPollerLro<OptionsT extends OperationOptions>(settings: {\n  client: GeneratedClient;\n  tracing: TracingClient;\n  options: OptionsT;\n}): LongRunningOperation {\n  const { client, options, tracing } = settings;\n  return {\n    async sendInitialRequest(): Promise<LroResponse<unknown>> {\n      throw new Error(`The operation has already started`);\n    },\n    sendPollRequest: createSendPollRequest({\n      client,\n      options,\n      spanStr: `${clientName}.beginAnalyzeBatch`,\n      tracing,\n    }),\n  };\n}\n\n/**\n * @internal\n */\nexport function processAnalyzeResult(options: {\n  client: GeneratedClient;\n  tracing: TracingClient;\n  docIds: string[];\n  opOptions: AnalyzeTextJobStatusOptionalParams;\n  state: { continuationToken: string };\n}): (result: unknown, state: AnalyzeBatchOperationState) => PagedAnalyzeBatchResult {\n  return (): PagedAnalyzeBatchResult => {\n    const { client, docIds, opOptions, tracing, state } = options;\n    const pageURL = state.continuationToken;\n    const pagedResult: PagedResult<AnalyzeBatchResult[]> = {\n      firstPageLink: pageURL,\n      getPage: async (pageLink: string, maxPageSize?: number) => {\n        const response = await sendRequest({\n          client,\n          spec: jobStatusOperationSpec,\n          spanStr: `${clientName}.beginAnalyzeBatch`,\n          // if `top` is set to `undefined`, the default value will not be sent\n          // as part of the request.\n          opOptions: maxPageSize ? { ...opOptions, top: maxPageSize } : opOptions,\n          path: pageLink,\n          tracing,\n        });\n        const flatResponse = response.flatResponse as AnalyzeTextJobStatusResponse;\n        return {\n          page: transformAnalyzeBatchResults(docIds, flatResponse.tasks.items, flatResponse.errors),\n          nextPageLink: flatResponse.nextLink,\n        };\n      },\n    };\n    return getPagedAsyncIterator(pagedResult);\n  };\n}\n\ntype Writable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * @internal\n */\nexport function createUpdateAnalyzeState(docIds?: string[]) {\n  return (state: AnalyzeBatchOperationState, lastResponse: LroResponse): void => {\n    const { createdOn, modifiedOn, id, displayName, expiresOn, tasks, lastUpdateDateTime } =\n      lastResponse.flatResponse as AnalyzeTextJobStatusResponse & { lastUpdateDateTime: string };\n    const mutableState = state as Writable<AnalyzeBatchOperationState> & {\n      docIds?: string[];\n    };\n    mutableState.createdOn = createdOn;\n    // FIXME: remove this mitigation when the service API is fixed\n    mutableState.modifiedOn = modifiedOn ? modifiedOn : new Date(lastUpdateDateTime);\n    mutableState.expiresOn = expiresOn;\n    mutableState.displayName = displayName;\n    mutableState.id = id;\n    mutableState.actionSucceededCount = tasks.completed;\n    mutableState.actionFailedCount = tasks.failed;\n    mutableState.actionInProgressCount = tasks.inProgress;\n    if (mutableState.docIds === undefined && docIds !== undefined) {\n      mutableState.docIds = docIds;\n    }\n  };\n}\n\n/**\n * @internal\n */\nexport function createPollerWithCancellation(settings: {\n  poller: SimplePollerLike<AnalyzeBatchOperationState, PagedAnalyzeBatchResult>;\n  client: GeneratedClient;\n  tracing: TracingClient;\n  options: AnalyzeTextJobStatusOptionalParams;\n  id: string;\n}): PollerLike<AnalyzeBatchOperationState, PagedAnalyzeBatchResult> {\n  const { client, options, poller, id, tracing } = settings;\n  return {\n    ...poller,\n    sendCancellationRequest: async () => {\n      await tracing.withSpan(`${clientName}.beginAnalyzeBatch`, options, async (finalOptions) =>\n        throwError(\n          getRawResponse(\n            (paramOptions) => client.analyzeText.cancelJob(id, paramOptions),\n            finalOptions\n          )\n        )\n      );\n    },\n  };\n}\n"]}