// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import * as Mappers from "./generated/models/mappers";
import * as Parameters from "./generated/models/parameters";
import { createSerializer, } from "@azure/core-client";
import { getPagedAsyncIterator } from "@azure/core-paging";
import { throwError, transformAnalyzeBatchResults } from "./transforms";
import { clientName } from "./constants";
import { logger } from "./logger";
const serializer = createSerializer(Mappers, /* isXml */ false);
const jobStatusOperationSpec = {
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeTextJobState,
        },
        default: {
            bodyMapper: Mappers.ErrorResponse,
        },
    },
    headerParameters: [Parameters.accept],
    queryParameters: [Parameters.top, Parameters.skip, Parameters.includeStatistics],
    serializer,
};
function addOnResponse(options, cb) {
    return Object.assign(Object.assign({}, options), { onResponse: (rawResponse, response, error) => {
            var _a;
            cb(rawResponse, response, error);
            (_a = options.onResponse) === null || _a === void 0 ? void 0 : _a.call(options, rawResponse, response, error);
        } });
}
function logWarnHeader(rawResponse) {
    const warnHeader = rawResponse.headers.get("warn-text");
    if (warnHeader) {
        warnHeader.split(";").map((x) => logger.warning(x));
    }
}
async function getRawResponse(getResponse, options) {
    let rawResponse;
    const flatResponse = await getResponse(addOnResponse(options, (response) => {
        rawResponse = response;
    }));
    return {
        flatResponse,
        rawResponse: {
            statusCode: rawResponse.status,
            headers: rawResponse.headers.toJSON(),
            body: rawResponse.parsedBody,
        },
    };
}
async function sendRequest(settings) {
    const { client, opOptions, path, spanStr, spec, tracing, httpMethod = "GET" } = settings;
    return tracing.withSpan(spanStr, opOptions, async (finalOptions) => throwError(getRawResponse((options) => client.sendOperationRequest({ options }, Object.assign(Object.assign({}, spec), { path,
        httpMethod })), finalOptions)));
}
/**
 * @internal
 */
function createSendPollRequest(settings) {
    const { client, options, tracing, spanStr } = settings;
    return async (path) => {
        return throwError(sendRequest({
            client,
            opOptions: addOnResponse(options, (_, response) => {
                const castResponse = response;
                if (castResponse.status.toLowerCase() === "partiallysucceeded") {
                    castResponse.status = "succeeded";
                }
            }),
            path,
            spanStr,
            spec: jobStatusOperationSpec,
            tracing,
        }));
    };
}
/**
 * @internal
 */
export function createAnalyzeBatchLro(settings) {
    const { client, commonOptions, documents, initialRequestOptions, pollRequestOptions, tasks, tracing, } = settings;
    return {
        async sendInitialRequest() {
            return tracing.withSpan(`${clientName}.beginAnalyzeBatch`, addOnResponse(Object.assign(Object.assign({}, commonOptions), initialRequestOptions), logWarnHeader), async (finalOptions) => throwError(getRawResponse((paramOptions) => client.analyzeBatch({
                tasks,
                analysisInput: {
                    documents,
                },
                displayName: initialRequestOptions.displayName,
            }, paramOptions), finalOptions)));
        },
        sendPollRequest: createSendPollRequest({
            client,
            options: Object.assign(Object.assign({}, commonOptions), pollRequestOptions),
            spanStr: `${clientName}.beginAnalyzeBatch`,
            tracing,
        }),
    };
}
/**
 * @internal
 */
export function getDocIDsFromState(serializedState) {
    try {
        const { docIds } = JSON.parse(serializedState).state;
        return docIds;
    }
    catch (e) {
        logger.error(`Document IDs are not found in the LRO's state. The results may not be ordered correctly.`);
        return [];
    }
}
/**
 * @internal
 */
export function createCreateAnalyzeBatchPollerLro(settings) {
    const { client, options, tracing } = settings;
    return {
        async sendInitialRequest() {
            throw new Error(`The operation has already started`);
        },
        sendPollRequest: createSendPollRequest({
            client,
            options,
            spanStr: `${clientName}.beginAnalyzeBatch`,
            tracing,
        }),
    };
}
/**
 * @internal
 */
export function processAnalyzeResult(options) {
    return () => {
        const { client, docIds, opOptions, tracing, state } = options;
        const pageURL = state.continuationToken;
        const pagedResult = {
            firstPageLink: pageURL,
            getPage: async (pageLink, maxPageSize) => {
                const response = await sendRequest({
                    client,
                    spec: jobStatusOperationSpec,
                    spanStr: `${clientName}.beginAnalyzeBatch`,
                    // if `top` is set to `undefined`, the default value will not be sent
                    // as part of the request.
                    opOptions: maxPageSize ? Object.assign(Object.assign({}, opOptions), { top: maxPageSize }) : opOptions,
                    path: pageLink,
                    tracing,
                });
                const flatResponse = response.flatResponse;
                return {
                    page: transformAnalyzeBatchResults(docIds, flatResponse.tasks.items, flatResponse.errors),
                    nextPageLink: flatResponse.nextLink,
                };
            },
        };
        return getPagedAsyncIterator(pagedResult);
    };
}
/**
 * @internal
 */
export function createUpdateAnalyzeState(docIds) {
    return (state, lastResponse) => {
        const { createdOn, modifiedOn, id, displayName, expiresOn, tasks, lastUpdateDateTime } = lastResponse.flatResponse;
        const mutableState = state;
        mutableState.createdOn = createdOn;
        // FIXME: remove this mitigation when the service API is fixed
        mutableState.modifiedOn = modifiedOn ? modifiedOn : new Date(lastUpdateDateTime);
        mutableState.expiresOn = expiresOn;
        mutableState.displayName = displayName;
        mutableState.id = id;
        mutableState.actionSucceededCount = tasks.completed;
        mutableState.actionFailedCount = tasks.failed;
        mutableState.actionInProgressCount = tasks.inProgress;
        if (mutableState.docIds === undefined && docIds !== undefined) {
            mutableState.docIds = docIds;
        }
    };
}
/**
 * @internal
 */
export function createPollerWithCancellation(settings) {
    const { client, options, poller, id, tracing } = settings;
    return Object.assign(Object.assign({}, poller), { sendCancellationRequest: async () => {
            await tracing.withSpan(`${clientName}.beginAnalyzeBatch`, options, async (finalOptions) => throwError(getRawResponse((paramOptions) => client.analyzeText.cancelJob(id, paramOptions), finalOptions)));
        } });
}
//# sourceMappingURL=lro.js.map