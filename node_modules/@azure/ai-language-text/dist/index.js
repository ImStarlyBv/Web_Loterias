'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
var coreClient = require('@azure/core-client');
var corePaging = require('@azure/core-paging');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default AAD permissions scope for Cognitive Services.
 * @internal
 */
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * @internal
 */
const SDK_VERSION = "1.1.0";
/**
 * @internal
 */
const clientName = "TextAnalysisClient";

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 * @internal
 */
const logger = logger$1.createClientLogger("ai-language-text");

// Copyright (c) Microsoft Corporation.
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @internal
 * @param sortedIds - An array of sorted IDs
 * @param unsortedArray - An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedIds, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedIds.length) {
        const ordinal = unsortedArray.length > sortedIds.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    /**
     * When the results are returned in pages, sortedArray will probably have more
     * items than unsortedArray so it is ok to ignore the case when a sorted item
     * ID is not found in `unsortedMap`.
     */
    for (const id of sortedIds) {
        const item = unsortedMap.get(id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
/**
 * @internal
 */
function parseAssessmentIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/assessments\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const assessmentIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            assessment: parseInt(res[3]),
        };
        return assessmentIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid Assessment pointer`);
    }
}
/**
 * Parses the index of the healthcare entity from a JSON pointer.
 * @param pointer - a JSON pointer representing an entity
 * @internal
 */
function parseHealthcareEntityIndex(pointer) {
    const regex = new RegExp(/#\/results\/documents\/(\d+)\/entities\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        return parseInt(res[2]);
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid healthcare entity pointer`);
    }
}
/**
 * @internal
 */
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
/**
 * @internal
 */
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text,
        };
    });
}
/**
 * @internal
 */
function convertToLanguageDetectionInput(inputs, countryHint) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text,
        };
    });
}
/**
 * @internal
 */
function getOperationOptions(options) {
    const { abortSignal, includeStatistics, onResponse, requestOptions, serializerOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "includeStatistics", "onResponse", "requestOptions", "serializerOptions", "tracingOptions"]);
    return {
        options: {
            abortSignal,
            includeStatistics,
            onResponse,
            requestOptions,
            serializerOptions,
            tracingOptions,
        },
        rest,
    };
}
/**
 *
 * @param error - error with the target in the JSON error pointer format "#/items/0
 * @returns number: the position of the task with error
 */
function extractErrorPointerIndex(error) {
    if (!error.target) {
        throw new Error("Unexpected response from service - no target present");
    }
    const position = parseInt(error.target.split("/").pop());
    if (isNaN(position)) {
        throw new Error(`Unexpected response from service - action pointer "${error.target}" is not a valid action pointer.`);
    }
    return position;
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AnalyzeAction = {
    type: {
        name: "Composite",
        className: "AnalyzeAction",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalyzeTextTaskResult = {
    type: {
        name: "Composite",
        className: "AnalyzeTextTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerErrorModel"
                }
            }
        }
    }
};
const InnerErrorModel = {
    type: {
        name: "Composite",
        className: "InnerErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerErrorModel"
                }
            }
        }
    }
};
const AnalyzeTextJobsInput = {
    type: {
        name: "Composite",
        className: "AnalyzeTextJobsInput",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            },
            tasks: {
                serializedName: "tasks",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalyzeBatchAction"
                        }
                    }
                }
            }
        }
    }
};
const MultiLanguageAnalysisInput = {
    type: {
        name: "Composite",
        className: "MultiLanguageAnalysisInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextDocumentInput"
                        }
                    }
                }
            }
        }
    }
};
const TextDocumentInput = {
    type: {
        name: "Composite",
        className: "TextDocumentInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchActionState = {
    type: {
        name: "Composite",
        className: "BatchActionState",
        modelProperties: {
            actionName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobState = {
    type: {
        name: "Composite",
        className: "JobState",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expiresOn: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            id: {
                serializedName: "jobId",
                required: true,
                type: {
                    name: "String"
                }
            },
            modifiedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TasksState = {
    type: {
        name: "Composite",
        className: "TasksState",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "TasksStateTasks"
                }
            }
        }
    }
};
const TasksStateTasks = {
    type: {
        name: "Composite",
        className: "TasksStateTasks",
        modelProperties: {
            completed: {
                serializedName: "completed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            failed: {
                serializedName: "failed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            inProgress: {
                serializedName: "inProgress",
                required: true,
                type: {
                    name: "Number"
                }
            },
            total: {
                serializedName: "total",
                required: true,
                type: {
                    name: "Number"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalyzeTextLROResult"
                        }
                    }
                }
            }
        }
    }
};
const TaskState = {
    type: {
        name: "Composite",
        className: "TaskState",
        modelProperties: {
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalyzeTextJobStatistics = {
    type: {
        name: "Composite",
        className: "AnalyzeTextJobStatistics",
        modelProperties: {
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                serializedName: "documentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                serializedName: "validDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                serializedName: "erroneousDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LanguageDetectionAnalysisInput = {
    type: {
        name: "Composite",
        className: "LanguageDetectionAnalysisInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LanguageDetectionInput"
                        }
                    }
                }
            }
        }
    }
};
const LanguageDetectionInput = {
    type: {
        name: "Composite",
        className: "LanguageDetectionInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActionCommon = {
    type: {
        name: "Composite",
        className: "ActionCommon",
        modelProperties: {
            disableServiceLogs: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CustomResult = {
    type: {
        name: "Composite",
        className: "CustomResult",
        modelProperties: {
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            projectName: {
                serializedName: "projectName",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentError = {
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const Entity = {
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentResult = {
    type: {
        name: "Composite",
        className: "DocumentResult",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const DocumentWarning = {
    type: {
        name: "Composite",
        className: "DocumentWarning",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                serializedName: "charactersCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClassificationCategory = {
    type: {
        name: "Composite",
        className: "ClassificationCategory",
        modelProperties: {
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HealthcareEntity = {
    type: {
        name: "Composite",
        className: "HealthcareEntity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            assertion: {
                serializedName: "assertion",
                type: {
                    name: "Composite",
                    className: "HealthcareAssertion"
                }
            },
            normalizedText: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            dataSources: {
                serializedName: "links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntityDataSource"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareAssertion = {
    type: {
        name: "Composite",
        className: "HealthcareAssertion",
        modelProperties: {
            conditionality: {
                serializedName: "conditionality",
                type: {
                    name: "Enum",
                    allowedValues: ["hypothetical", "conditional"]
                }
            },
            certainty: {
                serializedName: "certainty",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "positive",
                        "positivePossible",
                        "neutralPossible",
                        "negativePossible",
                        "negative"
                    ]
                }
            },
            association: {
                serializedName: "association",
                type: {
                    name: "Enum",
                    allowedValues: ["subject", "other"]
                }
            }
        }
    }
};
const EntityDataSource = {
    type: {
        name: "Composite",
        className: "EntityDataSource",
        modelProperties: {
            name: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            entityId: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareRelation = {
    type: {
        name: "Composite",
        className: "HealthcareRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                type: {
                    name: "Number"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelationEntity"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareRelationEntity = {
    type: {
        name: "Composite",
        className: "HealthcareRelationEntity",
        modelProperties: {
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "role",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PreBuiltResult = {
    type: {
        name: "Composite",
        className: "PreBuiltResult",
        modelProperties: {
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            neutral: {
                serializedName: "neutral",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            targets: {
                serializedName: "targets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceTarget"
                        }
                    }
                }
            },
            assessments: {
                serializedName: "assessments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AssessmentSentiment"
                        }
                    }
                }
            }
        }
    }
};
const SentenceTarget = {
    type: {
        name: "Composite",
        className: "SentenceTarget",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TargetRelation"
                        }
                    }
                }
            }
        }
    }
};
const TargetConfidenceScores = {
    type: {
        name: "Composite",
        className: "TargetConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TargetRelation = {
    type: {
        name: "Composite",
        className: "TargetRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["assessment", "target"]
                }
            },
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssessmentSentiment = {
    type: {
        name: "Composite",
        className: "AssessmentSentiment",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LinkedEntity = {
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            matches: {
                serializedName: "matches",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Match"
                        }
                    }
                }
            },
            language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            bingEntitySearchApiId: {
                serializedName: "bingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SummarySentence = {
    type: {
        name: "Composite",
        className: "SummarySentence",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            rankScore: {
                serializedName: "rankScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DetectedLanguage = {
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                serializedName: "iso6391Name",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Pagination = {
    type: {
        name: "Composite",
        className: "Pagination",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobErrors = {
    type: {
        name: "Composite",
        className: "JobErrors",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            }
        }
    }
};
const AbstractiveSummarizationTaskParametersBase = {
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationTaskParametersBase",
        modelProperties: {
            sentenceCount: {
                serializedName: "sentenceCount",
                type: {
                    name: "Number"
                }
            },
            stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AbstractiveSummarizationResultBase = {
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationResultBase",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AbstractiveSummaryDocumentResult"
                        }
                    }
                }
            }
        }
    }
};
const AbstractiveSummary = {
    type: {
        name: "Composite",
        className: "AbstractiveSummary",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            contexts: {
                serializedName: "contexts",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SummaryContext"
                        }
                    }
                }
            }
        }
    }
};
const SummaryContext = {
    type: {
        name: "Composite",
        className: "SummaryContext",
        modelProperties: {
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeTextEntityLinkingInput = {
    serializedName: "EntityLinking",
    type: {
        name: "Composite",
        className: "AnalyzeTextEntityLinkingInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityLinkingAction"
                }
            } })
    }
};
const AnalyzeTextEntityRecognitionInput = {
    serializedName: "EntityRecognition",
    type: {
        name: "Composite",
        className: "AnalyzeTextEntityRecognitionInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityRecognitionAction"
                }
            } })
    }
};
const AnalyzeTextKeyPhraseExtractionInput = {
    serializedName: "KeyPhraseExtraction",
    type: {
        name: "Composite",
        className: "AnalyzeTextKeyPhraseExtractionInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "KeyPhraseExtractionAction"
                }
            } })
    }
};
const AnalyzeTextPiiEntitiesRecognitionInput = {
    serializedName: "PiiEntityRecognition",
    type: {
        name: "Composite",
        className: "AnalyzeTextPiiEntitiesRecognitionInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PiiEntityRecognitionAction"
                }
            } })
    }
};
const AnalyzeTextLanguageDetectionInput = {
    serializedName: "LanguageDetection",
    type: {
        name: "Composite",
        className: "AnalyzeTextLanguageDetectionInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "LanguageDetectionAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "LanguageDetectionAction"
                }
            } })
    }
};
const AnalyzeTextSentimentAnalysisInput = {
    serializedName: "SentimentAnalysis",
    type: {
        name: "Composite",
        className: "AnalyzeTextSentimentAnalysisInput",
        uberParent: "AnalyzeAction",
        polymorphicDiscriminator: AnalyzeAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeAction.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageAnalysisInput"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SentimentAnalysisAction"
                }
            } })
    }
};
const SentimentTaskResult = {
    serializedName: "SentimentAnalysisResults",
    type: {
        name: "Composite",
        className: "SentimentTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "SentimentResponse"
                }
            } })
    }
};
const EntitiesTaskResult = {
    serializedName: "EntityRecognitionResults",
    type: {
        name: "Composite",
        className: "EntitiesTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntitiesResult"
                }
            } })
    }
};
const EntityLinkingTaskResult = {
    serializedName: "EntityLinkingResults",
    type: {
        name: "Composite",
        className: "EntityLinkingTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntityLinkingResult"
                }
            } })
    }
};
const PiiTaskResult = {
    serializedName: "PiiEntityRecognitionResults",
    type: {
        name: "Composite",
        className: "PiiTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "PiiResult"
                }
            } })
    }
};
const KeyPhraseTaskResult = {
    serializedName: "KeyPhraseExtractionResults",
    type: {
        name: "Composite",
        className: "KeyPhraseTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "KeyPhraseResult"
                }
            } })
    }
};
const LanguageDetectionTaskResult = {
    serializedName: "LanguageDetectionResults",
    type: {
        name: "Composite",
        className: "LanguageDetectionTaskResult",
        uberParent: "AnalyzeTextTaskResult",
        polymorphicDiscriminator: AnalyzeTextTaskResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextTaskResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "LanguageDetectionResult"
                }
            } })
    }
};
const AnalyzeBatchAction = {
    serializedName: "AnalyzeBatchAction",
    type: {
        name: "Composite",
        className: "AnalyzeBatchAction",
        uberParent: "BatchActionState",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, BatchActionState.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AnalyzeTextLROResult = {
    serializedName: "AnalyzeTextLROResult",
    type: {
        name: "Composite",
        className: "AnalyzeTextLROResult",
        uberParent: "TaskState",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign(Object.assign({}, TaskState.type.modelProperties), BatchActionState.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AnalyzeTextJobState = {
    type: {
        name: "Composite",
        className: "AnalyzeTextJobState",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobState.type.modelProperties), TasksState.type.modelProperties), AnalyzeTextJobStatistics.type.modelProperties)
    }
};
const ActionPrebuilt = {
    type: {
        name: "Composite",
        className: "ActionPrebuilt",
        modelProperties: Object.assign(Object.assign({}, ActionCommon.type.modelProperties), { modelVersion: {
                defaultValue: "latest",
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const ActionCustom = {
    type: {
        name: "Composite",
        className: "ActionCustom",
        modelProperties: Object.assign(Object.assign({}, ActionCommon.type.modelProperties), { projectName: {
                serializedName: "projectName",
                required: true,
                type: {
                    name: "String"
                }
            }, deploymentName: {
                serializedName: "deploymentName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomEntitiesResult = {
    type: {
        name: "Composite",
        className: "CustomEntitiesResult",
        modelProperties: Object.assign(Object.assign({}, CustomResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntitiesResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const CustomLabelClassificationResult = {
    type: {
        name: "Composite",
        className: "CustomLabelClassificationResult",
        modelProperties: Object.assign(Object.assign({}, CustomResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomLabelClassificationResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const EntitiesDocumentResult = {
    type: {
        name: "Composite",
        className: "EntitiesDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            } })
    }
};
const ClassificationDocumentResult = {
    type: {
        name: "Composite",
        className: "ClassificationDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { classifications: {
                serializedName: "class",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClassificationCategory"
                        }
                    }
                }
            } })
    }
};
const HealthcareEntitiesDocumentResult = {
    type: {
        name: "Composite",
        className: "HealthcareEntitiesDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntity"
                        }
                    }
                }
            }, relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelation"
                        }
                    }
                }
            } })
    }
};
const SentimentDocumentResult = {
    type: {
        name: "Composite",
        className: "SentimentDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative", "mixed"]
                }
            }, confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            }, sentences: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceSentiment"
                        }
                    }
                }
            } })
    }
};
const LinkedEntitiesDocumentResult = {
    type: {
        name: "Composite",
        className: "LinkedEntitiesDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedEntity"
                        }
                    }
                }
            } })
    }
};
const PiiEntitiesDocumentResult = {
    type: {
        name: "Composite",
        className: "PiiEntitiesDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { redactedText: {
                serializedName: "redactedText",
                required: true,
                type: {
                    name: "String"
                }
            }, entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            } })
    }
};
const ExtractedSummaryDocumentResult = {
    type: {
        name: "Composite",
        className: "ExtractedSummaryDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { sentences: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SummarySentence"
                        }
                    }
                }
            } })
    }
};
const KeyPhrasesDocumentResult = {
    type: {
        name: "Composite",
        className: "KeyPhrasesDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { keyPhrases: {
                serializedName: "keyPhrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LanguageDetectionDocumentResult = {
    type: {
        name: "Composite",
        className: "LanguageDetectionDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { detectedLanguage: {
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            } })
    }
};
const AbstractiveSummaryDocumentResult = {
    type: {
        name: "Composite",
        className: "AbstractiveSummaryDocumentResult",
        modelProperties: Object.assign(Object.assign({}, DocumentResult.type.modelProperties), { summaries: {
                serializedName: "summaries",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AbstractiveSummary"
                        }
                    }
                }
            } })
    }
};
const HealthcareResult = {
    type: {
        name: "Composite",
        className: "HealthcareResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const SentimentResponse = {
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentimentResponseDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const EntitiesResult = {
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntitiesResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const EntityLinkingResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntityLinkingResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const PiiResult = {
    type: {
        name: "Composite",
        className: "PiiResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const ExtractiveSummarizationResult = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtractedSummaryDocumentResult"
                        }
                    }
                }
            } })
    }
};
const KeyPhraseResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyPhraseResultDocumentsItem"
                        }
                    }
                }
            } })
    }
};
const LanguageDetectionResult = {
    type: {
        name: "Composite",
        className: "LanguageDetectionResult",
        modelProperties: Object.assign(Object.assign({}, PreBuiltResult.type.modelProperties), { documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LanguageDetectionDocumentResult"
                        }
                    }
                }
            } })
    }
};
const AbstractiveSummarizationResult = {
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationResult",
        modelProperties: Object.assign(Object.assign({}, AbstractiveSummarizationResultBase.type.modelProperties), PreBuiltResult.type.modelProperties)
    }
};
const AbstractiveSummarizationAction = {
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationAction",
        modelProperties: Object.assign(Object.assign({}, AbstractiveSummarizationTaskParametersBase.type.modelProperties), ActionPrebuilt.type.modelProperties)
    }
};
const CustomEntitiesLROTask = {
    serializedName: "CustomEntityRecognition",
    type: {
        name: "Composite",
        className: "CustomEntitiesLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomEntityRecognitionAction"
                }
            } })
    }
};
const CustomSingleLabelClassificationLROTask = {
    serializedName: "CustomSingleLabelClassification",
    type: {
        name: "Composite",
        className: "CustomSingleLabelClassificationLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomSingleLabelClassificationAction"
                }
            } })
    }
};
const CustomMultiLabelClassificationLROTask = {
    serializedName: "CustomMultiLabelClassification",
    type: {
        name: "Composite",
        className: "CustomMultiLabelClassificationLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomMultiLabelClassificationAction"
                }
            } })
    }
};
const HealthcareLROTask = {
    serializedName: "Healthcare",
    type: {
        name: "Composite",
        className: "HealthcareLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "HealthcareAction"
                }
            } })
    }
};
const SentimentAnalysisLROTask = {
    serializedName: "SentimentAnalysis",
    type: {
        name: "Composite",
        className: "SentimentAnalysisLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SentimentAnalysisAction"
                }
            } })
    }
};
const EntitiesLROTask = {
    serializedName: "EntityRecognition",
    type: {
        name: "Composite",
        className: "EntitiesLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityRecognitionAction"
                }
            } })
    }
};
const EntityLinkingLROTask = {
    serializedName: "EntityLinking",
    type: {
        name: "Composite",
        className: "EntityLinkingLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityLinkingAction"
                }
            } })
    }
};
const PiiLROTask = {
    serializedName: "PiiEntityRecognition",
    type: {
        name: "Composite",
        className: "PiiLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PiiEntityRecognitionAction"
                }
            } })
    }
};
const ExtractiveSummarizationLROTask = {
    serializedName: "ExtractiveSummarization",
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "ExtractiveSummarizationAction"
                }
            } })
    }
};
const KeyPhraseLROTask = {
    serializedName: "KeyPhraseExtraction",
    type: {
        name: "Composite",
        className: "KeyPhraseLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "KeyPhraseExtractionAction"
                }
            } })
    }
};
const AbstractiveSummarizationLROTask = {
    serializedName: "AbstractiveSummarization",
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationLROTask",
        uberParent: "AnalyzeBatchAction",
        polymorphicDiscriminator: AnalyzeBatchAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeBatchAction.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "AbstractiveSummarizationAction"
                }
            } })
    }
};
const EntityRecognitionLROResult = {
    serializedName: "EntityRecognitionLROResults",
    type: {
        name: "Composite",
        className: "EntityRecognitionLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntitiesResult"
                }
            } })
    }
};
const CustomEntityRecognitionLROResult = {
    serializedName: "CustomEntityRecognitionLROResults",
    type: {
        name: "Composite",
        className: "CustomEntityRecognitionLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomEntitiesResult"
                }
            } })
    }
};
const CustomSingleLabelClassificationLROResult = {
    serializedName: "CustomSingleLabelClassificationLROResults",
    type: {
        name: "Composite",
        className: "CustomSingleLabelClassificationLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomLabelClassificationResult"
                }
            } })
    }
};
const CustomMultiLabelClassificationLROResult = {
    serializedName: "CustomMultiLabelClassificationLROResults",
    type: {
        name: "Composite",
        className: "CustomMultiLabelClassificationLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomLabelClassificationResult"
                }
            } })
    }
};
const EntityLinkingLROResult = {
    serializedName: "EntityLinkingLROResults",
    type: {
        name: "Composite",
        className: "EntityLinkingLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntityLinkingResult"
                }
            } })
    }
};
const PiiEntityRecognitionLROResult = {
    serializedName: "PiiEntityRecognitionLROResults",
    type: {
        name: "Composite",
        className: "PiiEntityRecognitionLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "PiiResult"
                }
            } })
    }
};
const ExtractiveSummarizationLROResult = {
    serializedName: "ExtractiveSummarizationLROResults",
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "ExtractiveSummarizationResult"
                }
            } })
    }
};
const HealthcareLROResult = {
    serializedName: "HealthcareLROResults",
    type: {
        name: "Composite",
        className: "HealthcareLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "HealthcareResult"
                }
            } })
    }
};
const SentimentLROResult = {
    serializedName: "SentimentAnalysisLROResults",
    type: {
        name: "Composite",
        className: "SentimentLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "SentimentResponse"
                }
            } })
    }
};
const KeyPhraseExtractionLROResult = {
    serializedName: "KeyPhraseExtractionLROResults",
    type: {
        name: "Composite",
        className: "KeyPhraseExtractionLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "KeyPhraseResult"
                }
            } })
    }
};
const AbstractiveSummarizationLROResult = {
    serializedName: "AbstractiveSummarizationLROResults",
    type: {
        name: "Composite",
        className: "AbstractiveSummarizationLROResult",
        uberParent: "AnalyzeTextLROResult",
        polymorphicDiscriminator: AnalyzeTextLROResult.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AnalyzeTextLROResult.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "AbstractiveSummarizationResult"
                }
            } })
    }
};
const EntityLinkingAction = {
    type: {
        name: "Composite",
        className: "EntityLinkingAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityRecognitionAction = {
    type: {
        name: "Composite",
        className: "EntityRecognitionAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const KeyPhraseExtractionAction = {
    type: {
        name: "Composite",
        className: "KeyPhraseExtractionAction",
        modelProperties: Object.assign({}, ActionPrebuilt.type.modelProperties)
    }
};
const PiiEntityRecognitionAction = {
    type: {
        name: "Composite",
        className: "PiiEntityRecognitionAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { domainFilter: {
                defaultValue: "none",
                serializedName: "domain",
                type: {
                    name: "String"
                }
            }, categoriesFilter: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "piiCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const LanguageDetectionAction = {
    type: {
        name: "Composite",
        className: "LanguageDetectionAction",
        modelProperties: Object.assign({}, ActionPrebuilt.type.modelProperties)
    }
};
const SentimentAnalysisAction = {
    type: {
        name: "Composite",
        className: "SentimentAnalysisAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { includeOpinionMining: {
                defaultValue: false,
                serializedName: "opinionMining",
                type: {
                    name: "Boolean"
                }
            }, stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const HealthcareAction = {
    type: {
        name: "Composite",
        className: "HealthcareAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ExtractiveSummarizationAction = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationAction",
        modelProperties: Object.assign(Object.assign({}, ActionPrebuilt.type.modelProperties), { maxSentenceCount: {
                defaultValue: 3,
                serializedName: "sentenceCount",
                type: {
                    name: "Number"
                }
            }, orderBy: {
                defaultValue: "Offset",
                serializedName: "sortBy",
                type: {
                    name: "String"
                }
            }, stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomEntityRecognitionAction = {
    type: {
        name: "Composite",
        className: "CustomEntityRecognitionAction",
        modelProperties: Object.assign(Object.assign({}, ActionCustom.type.modelProperties), { stringIndexType: {
                defaultValue: "Utf16CodeUnit",
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomSingleLabelClassificationAction = {
    type: {
        name: "Composite",
        className: "CustomSingleLabelClassificationAction",
        modelProperties: Object.assign({}, ActionCustom.type.modelProperties)
    }
};
const CustomMultiLabelClassificationAction = {
    type: {
        name: "Composite",
        className: "CustomMultiLabelClassificationAction",
        modelProperties: Object.assign({}, ActionCustom.type.modelProperties)
    }
};
const CustomEntitiesResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "CustomEntitiesResultDocumentsItem",
        modelProperties: Object.assign({}, EntitiesDocumentResult.type.modelProperties)
    }
};
const EntitiesResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "EntitiesResultDocumentsItem",
        modelProperties: Object.assign({}, EntitiesDocumentResult.type.modelProperties)
    }
};
const CustomLabelClassificationResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "CustomLabelClassificationResultDocumentsItem",
        modelProperties: Object.assign({}, ClassificationDocumentResult.type.modelProperties)
    }
};
const HealthcareResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "HealthcareResultDocumentsItem",
        modelProperties: Object.assign({}, HealthcareEntitiesDocumentResult.type.modelProperties)
    }
};
const SentimentResponseDocumentsItem = {
    type: {
        name: "Composite",
        className: "SentimentResponseDocumentsItem",
        modelProperties: Object.assign({}, SentimentDocumentResult.type.modelProperties)
    }
};
const EntityLinkingResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "EntityLinkingResultDocumentsItem",
        modelProperties: Object.assign({}, LinkedEntitiesDocumentResult.type.modelProperties)
    }
};
const PiiResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "PiiResultDocumentsItem",
        modelProperties: Object.assign({}, PiiEntitiesDocumentResult.type.modelProperties)
    }
};
const KeyPhraseResultDocumentsItem = {
    type: {
        name: "Composite",
        className: "KeyPhraseResultDocumentsItem",
        modelProperties: Object.assign({}, KeyPhrasesDocumentResult.type.modelProperties)
    }
};
const GeneratedClientAnalyzeBatchHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeBatchHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalyzeTextCancelJobHeaders = {
    type: {
        name: "Composite",
        className: "AnalyzeTextCancelJobHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    AnalyzeAction: AnalyzeAction,
    AnalyzeTextTaskResult: AnalyzeTextTaskResult,
    "AnalyzeAction.EntityLinking": AnalyzeTextEntityLinkingInput,
    "AnalyzeAction.EntityRecognition": AnalyzeTextEntityRecognitionInput,
    "AnalyzeAction.KeyPhraseExtraction": AnalyzeTextKeyPhraseExtractionInput,
    "AnalyzeAction.PiiEntityRecognition": AnalyzeTextPiiEntitiesRecognitionInput,
    "AnalyzeAction.LanguageDetection": AnalyzeTextLanguageDetectionInput,
    "AnalyzeAction.SentimentAnalysis": AnalyzeTextSentimentAnalysisInput,
    "AnalyzeTextTaskResult.SentimentAnalysisResults": SentimentTaskResult,
    "AnalyzeTextTaskResult.EntityRecognitionResults": EntitiesTaskResult,
    "AnalyzeTextTaskResult.EntityLinkingResults": EntityLinkingTaskResult,
    "AnalyzeTextTaskResult.PiiEntityRecognitionResults": PiiTaskResult,
    "AnalyzeTextTaskResult.KeyPhraseExtractionResults": KeyPhraseTaskResult,
    "AnalyzeTextTaskResult.LanguageDetectionResults": LanguageDetectionTaskResult,
    "BatchActionState.AnalyzeBatchAction": AnalyzeBatchAction,
    "TaskState.AnalyzeTextLROResult": AnalyzeTextLROResult,
    "AnalyzeBatchAction.CustomEntityRecognition": CustomEntitiesLROTask,
    "AnalyzeBatchAction.CustomSingleLabelClassification": CustomSingleLabelClassificationLROTask,
    "AnalyzeBatchAction.CustomMultiLabelClassification": CustomMultiLabelClassificationLROTask,
    "AnalyzeBatchAction.Healthcare": HealthcareLROTask,
    "AnalyzeBatchAction.SentimentAnalysis": SentimentAnalysisLROTask,
    "AnalyzeBatchAction.EntityRecognition": EntitiesLROTask,
    "AnalyzeBatchAction.EntityLinking": EntityLinkingLROTask,
    "AnalyzeBatchAction.PiiEntityRecognition": PiiLROTask,
    "AnalyzeBatchAction.ExtractiveSummarization": ExtractiveSummarizationLROTask,
    "AnalyzeBatchAction.KeyPhraseExtraction": KeyPhraseLROTask,
    "AnalyzeBatchAction.AbstractiveSummarization": AbstractiveSummarizationLROTask,
    "AnalyzeTextLROResult.EntityRecognitionLROResults": EntityRecognitionLROResult,
    "AnalyzeTextLROResult.CustomEntityRecognitionLROResults": CustomEntityRecognitionLROResult,
    "AnalyzeTextLROResult.CustomSingleLabelClassificationLROResults": CustomSingleLabelClassificationLROResult,
    "AnalyzeTextLROResult.CustomMultiLabelClassificationLROResults": CustomMultiLabelClassificationLROResult,
    "AnalyzeTextLROResult.EntityLinkingLROResults": EntityLinkingLROResult,
    "AnalyzeTextLROResult.PiiEntityRecognitionLROResults": PiiEntityRecognitionLROResult,
    "AnalyzeTextLROResult.ExtractiveSummarizationLROResults": ExtractiveSummarizationLROResult,
    "AnalyzeTextLROResult.HealthcareLROResults": HealthcareLROResult,
    "AnalyzeTextLROResult.SentimentAnalysisLROResults": SentimentLROResult,
    "AnalyzeTextLROResult.KeyPhraseExtractionLROResults": KeyPhraseExtractionLROResult,
    "AnalyzeTextLROResult.AbstractiveSummarizationLROResults": AbstractiveSummarizationLROResult
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnalyzeAction: AnalyzeAction,
    AnalyzeTextTaskResult: AnalyzeTextTaskResult,
    ErrorResponse: ErrorResponse,
    ErrorModel: ErrorModel,
    InnerErrorModel: InnerErrorModel,
    AnalyzeTextJobsInput: AnalyzeTextJobsInput,
    MultiLanguageAnalysisInput: MultiLanguageAnalysisInput,
    TextDocumentInput: TextDocumentInput,
    BatchActionState: BatchActionState,
    JobState: JobState,
    TasksState: TasksState,
    TasksStateTasks: TasksStateTasks,
    TaskState: TaskState,
    AnalyzeTextJobStatistics: AnalyzeTextJobStatistics,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    LanguageDetectionAnalysisInput: LanguageDetectionAnalysisInput,
    LanguageDetectionInput: LanguageDetectionInput,
    ActionCommon: ActionCommon,
    CustomResult: CustomResult,
    DocumentError: DocumentError,
    Entity: Entity,
    DocumentResult: DocumentResult,
    DocumentWarning: DocumentWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    ClassificationCategory: ClassificationCategory,
    HealthcareEntity: HealthcareEntity,
    HealthcareAssertion: HealthcareAssertion,
    EntityDataSource: EntityDataSource,
    HealthcareRelation: HealthcareRelation,
    HealthcareRelationEntity: HealthcareRelationEntity,
    PreBuiltResult: PreBuiltResult,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    SentenceTarget: SentenceTarget,
    TargetConfidenceScores: TargetConfidenceScores,
    TargetRelation: TargetRelation,
    AssessmentSentiment: AssessmentSentiment,
    LinkedEntity: LinkedEntity,
    Match: Match,
    SummarySentence: SummarySentence,
    DetectedLanguage: DetectedLanguage,
    Pagination: Pagination,
    JobErrors: JobErrors,
    AbstractiveSummarizationTaskParametersBase: AbstractiveSummarizationTaskParametersBase,
    AbstractiveSummarizationResultBase: AbstractiveSummarizationResultBase,
    AbstractiveSummary: AbstractiveSummary,
    SummaryContext: SummaryContext,
    AnalyzeTextEntityLinkingInput: AnalyzeTextEntityLinkingInput,
    AnalyzeTextEntityRecognitionInput: AnalyzeTextEntityRecognitionInput,
    AnalyzeTextKeyPhraseExtractionInput: AnalyzeTextKeyPhraseExtractionInput,
    AnalyzeTextPiiEntitiesRecognitionInput: AnalyzeTextPiiEntitiesRecognitionInput,
    AnalyzeTextLanguageDetectionInput: AnalyzeTextLanguageDetectionInput,
    AnalyzeTextSentimentAnalysisInput: AnalyzeTextSentimentAnalysisInput,
    SentimentTaskResult: SentimentTaskResult,
    EntitiesTaskResult: EntitiesTaskResult,
    EntityLinkingTaskResult: EntityLinkingTaskResult,
    PiiTaskResult: PiiTaskResult,
    KeyPhraseTaskResult: KeyPhraseTaskResult,
    LanguageDetectionTaskResult: LanguageDetectionTaskResult,
    AnalyzeBatchAction: AnalyzeBatchAction,
    AnalyzeTextLROResult: AnalyzeTextLROResult,
    AnalyzeTextJobState: AnalyzeTextJobState,
    ActionPrebuilt: ActionPrebuilt,
    ActionCustom: ActionCustom,
    CustomEntitiesResult: CustomEntitiesResult,
    CustomLabelClassificationResult: CustomLabelClassificationResult,
    EntitiesDocumentResult: EntitiesDocumentResult,
    ClassificationDocumentResult: ClassificationDocumentResult,
    HealthcareEntitiesDocumentResult: HealthcareEntitiesDocumentResult,
    SentimentDocumentResult: SentimentDocumentResult,
    LinkedEntitiesDocumentResult: LinkedEntitiesDocumentResult,
    PiiEntitiesDocumentResult: PiiEntitiesDocumentResult,
    ExtractedSummaryDocumentResult: ExtractedSummaryDocumentResult,
    KeyPhrasesDocumentResult: KeyPhrasesDocumentResult,
    LanguageDetectionDocumentResult: LanguageDetectionDocumentResult,
    AbstractiveSummaryDocumentResult: AbstractiveSummaryDocumentResult,
    HealthcareResult: HealthcareResult,
    SentimentResponse: SentimentResponse,
    EntitiesResult: EntitiesResult,
    EntityLinkingResult: EntityLinkingResult,
    PiiResult: PiiResult,
    ExtractiveSummarizationResult: ExtractiveSummarizationResult,
    KeyPhraseResult: KeyPhraseResult,
    LanguageDetectionResult: LanguageDetectionResult,
    AbstractiveSummarizationResult: AbstractiveSummarizationResult,
    AbstractiveSummarizationAction: AbstractiveSummarizationAction,
    CustomEntitiesLROTask: CustomEntitiesLROTask,
    CustomSingleLabelClassificationLROTask: CustomSingleLabelClassificationLROTask,
    CustomMultiLabelClassificationLROTask: CustomMultiLabelClassificationLROTask,
    HealthcareLROTask: HealthcareLROTask,
    SentimentAnalysisLROTask: SentimentAnalysisLROTask,
    EntitiesLROTask: EntitiesLROTask,
    EntityLinkingLROTask: EntityLinkingLROTask,
    PiiLROTask: PiiLROTask,
    ExtractiveSummarizationLROTask: ExtractiveSummarizationLROTask,
    KeyPhraseLROTask: KeyPhraseLROTask,
    AbstractiveSummarizationLROTask: AbstractiveSummarizationLROTask,
    EntityRecognitionLROResult: EntityRecognitionLROResult,
    CustomEntityRecognitionLROResult: CustomEntityRecognitionLROResult,
    CustomSingleLabelClassificationLROResult: CustomSingleLabelClassificationLROResult,
    CustomMultiLabelClassificationLROResult: CustomMultiLabelClassificationLROResult,
    EntityLinkingLROResult: EntityLinkingLROResult,
    PiiEntityRecognitionLROResult: PiiEntityRecognitionLROResult,
    ExtractiveSummarizationLROResult: ExtractiveSummarizationLROResult,
    HealthcareLROResult: HealthcareLROResult,
    SentimentLROResult: SentimentLROResult,
    KeyPhraseExtractionLROResult: KeyPhraseExtractionLROResult,
    AbstractiveSummarizationLROResult: AbstractiveSummarizationLROResult,
    EntityLinkingAction: EntityLinkingAction,
    EntityRecognitionAction: EntityRecognitionAction,
    KeyPhraseExtractionAction: KeyPhraseExtractionAction,
    PiiEntityRecognitionAction: PiiEntityRecognitionAction,
    LanguageDetectionAction: LanguageDetectionAction,
    SentimentAnalysisAction: SentimentAnalysisAction,
    HealthcareAction: HealthcareAction,
    ExtractiveSummarizationAction: ExtractiveSummarizationAction,
    CustomEntityRecognitionAction: CustomEntityRecognitionAction,
    CustomSingleLabelClassificationAction: CustomSingleLabelClassificationAction,
    CustomMultiLabelClassificationAction: CustomMultiLabelClassificationAction,
    CustomEntitiesResultDocumentsItem: CustomEntitiesResultDocumentsItem,
    EntitiesResultDocumentsItem: EntitiesResultDocumentsItem,
    CustomLabelClassificationResultDocumentsItem: CustomLabelClassificationResultDocumentsItem,
    HealthcareResultDocumentsItem: HealthcareResultDocumentsItem,
    SentimentResponseDocumentsItem: SentimentResponseDocumentsItem,
    EntityLinkingResultDocumentsItem: EntityLinkingResultDocumentsItem,
    PiiResultDocumentsItem: PiiResultDocumentsItem,
    KeyPhraseResultDocumentsItem: KeyPhraseResultDocumentsItem,
    GeneratedClientAnalyzeBatchHeaders: GeneratedClientAnalyzeBatchHeaders,
    AnalyzeTextCancelJobHeaders: AnalyzeTextCancelJobHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: AnalyzeAction
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-04-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const includeStatistics = {
    parameterPath: ["options", "includeStatistics"],
    mapper: {
        serializedName: "showStats",
        type: {
            name: "Boolean"
        }
    }
};
const body1 = {
    parameterPath: "body",
    mapper: AnalyzeTextJobsInput
};
const jobId = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "top",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "skip",
        type: {
            name: "Number"
        }
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Helper function for converting nested service error to the unified
 * TextAnalysisError
 */
function toTextAnalysisError(errorModel) {
    // Return the deepest error.
    if (errorModel.innererror !== undefined) {
        return toTextAnalysisError(errorModel.innererror);
    }
    return Object.assign({}, errorModel);
}
function makeTextAnalysisErrorResult(id, error) {
    return {
        id,
        error: toTextAnalysisError(error),
    };
}
/**
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array.
 * @param ids - the array of input document IDs.
 * @param response - the response received from the service.
 * @param options - an options bag that includes functions to process the results.
 */
function transformDocumentResults(ids, response, options) {
    const { processError = makeTextAnalysisErrorResult, processSuccess } = options || {};
    const successResults = processSuccess
        ? response.documents.map(processSuccess)
        : response.documents;
    const unsortedResults = successResults.concat(response.errors.map((error) => processError(error.id, error.error)));
    return sortResponseIdObjects(ids, unsortedResults);
}
function toLanguageDetectionResult(docIds, results) {
    return transformDocumentResults(docIds, results, {
        processSuccess: (_a) => {
            var { detectedLanguage } = _a, rest = tslib.__rest(_a, ["detectedLanguage"]);
            return (Object.assign({ primaryLanguage: detectedLanguage }, rest));
        },
    });
}
function toPiiEntityRecognitionResult(docIds, results) {
    return transformDocumentResults(docIds, results);
}
function toSentimentAnalysisResult(docIds, results) {
    return transformDocumentResults(docIds, results, {
        processSuccess: (_a) => {
            var { sentences } = _a, rest = tslib.__rest(_a, ["sentences"]);
            return (Object.assign(Object.assign({}, rest), { sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, sentences)) }));
        },
    });
}
/**
 * Converts a sentence sentiment object returned by the service to another that
 * is user-friendly.
 *
 * @param sentence - The sentence sentiment object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly sentence sentiment object.
 * @internal
 */
function convertGeneratedSentenceSentiment(_a, sentences) {
    var _b;
    var { targets, assessments: _ } = _a, rest = tslib.__rest(_a, ["targets", "assessments"]);
    return Object.assign(Object.assign({}, rest), { opinions: (_b = targets === null || targets === void 0 ? void 0 : targets.map(
        // eslint-disable-next-line @typescript-eslint/no-shadow
        (_a) => {
            var { relations } = _a, rest = tslib.__rest(_a, ["relations"]);
            return ({
                target: rest,
                assessments: relations
                    .filter((relation) => relation.relationType === "assessment")
                    .map((relation) => convertTargetRelationToAssessmentSentiment(relation, sentences)),
            });
        })) !== null && _b !== void 0 ? _b : [] });
}
/**
 * Converts a target relation object returned by the service to an assessment
 * sentiment object where JSON pointers in the former are realized in the
 * latter.
 *
 * @param targetRelation - The target relation object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly assessment sentiment object.
 * @internal
 */
function convertTargetRelationToAssessmentSentiment(targetRelation, sentences) {
    var _a;
    const assessmentPtr = targetRelation.ref;
    const assessmentIndex = parseAssessmentIndex(assessmentPtr);
    const assessment = (_a = sentences === null || sentences === void 0 ? void 0 : sentences[assessmentIndex.sentence].assessments) === null || _a === void 0 ? void 0 : _a[assessmentIndex.assessment];
    if (assessment !== undefined) {
        return assessment;
    }
    else {
        throw new Error(`Pointer "${assessmentPtr}" is not a valid Assessment pointer`);
    }
}
function toEntityLinkingResult(docIds, results) {
    return transformDocumentResults(docIds, results);
}
function toKeyPhraseExtractionResult(docIds, results) {
    return transformDocumentResults(docIds, results);
}
function toEntityRecognitionResult(docIds, results) {
    return transformDocumentResults(docIds, results);
}
/**
 * @internal
 */
function transformActionResult(actionName, docIds, response) {
    switch (response.kind) {
        case "EntityLinkingResults": {
            return toEntityLinkingResult(docIds, response.results);
        }
        case "EntityRecognitionResults": {
            return toEntityRecognitionResult(docIds, response.results);
        }
        case "KeyPhraseExtractionResults": {
            return toKeyPhraseExtractionResult(docIds, response.results);
        }
        case "PiiEntityRecognitionResults": {
            return toPiiEntityRecognitionResult(docIds, response.results);
        }
        case "SentimentAnalysisResults": {
            return toSentimentAnalysisResult(docIds, response.results);
        }
        case "LanguageDetectionResults": {
            return toLanguageDetectionResult(docIds, response.results);
        }
        default: {
            const __exhaust = response;
            throw new Error(`Unsupported results kind: ${__exhaust} for an action of type ${actionName}`);
        }
    }
}
function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
        message = message + ".";
    }
    return message + " " + innerMessage;
}
/**
 * @internal
 * parses incoming errors from the service/
 * @param error - the incoming error
 */
function transformError(errorResponse) {
    var _a;
    const strongErrorResponse = errorResponse;
    if (!strongErrorResponse.response) {
        throw errorResponse;
    }
    const topLevelError = (_a = strongErrorResponse.response.parsedBody) === null || _a === void 0 ? void 0 : _a.error;
    if (!topLevelError)
        return errorResponse;
    let errorMessage = topLevelError.message;
    let code = topLevelError.code;
    function unwrap(error) {
        const innerError = error.innererror;
        if (innerError) {
            if (innerError.message) {
                errorMessage = appendReadableErrorMessage(errorMessage, innerError.message);
            }
            if (innerError.code) {
                code = innerError.code;
            }
            return unwrap(innerError);
        }
        return error;
    }
    unwrap(topLevelError);
    return new coreRestPipeline.RestError(errorMessage, {
        code,
        statusCode: strongErrorResponse.statusCode,
    });
}
async function throwError(p) {
    try {
        return await p;
    }
    catch (e) {
        throw transformError(e);
    }
}
function toHealthcareResult(docIds, results) {
    function makeHealthcareEntity(entity) {
        const { dataSources } = entity, rest = tslib.__rest(entity, ["dataSources"]);
        return Object.assign({ dataSources: dataSources !== null && dataSources !== void 0 ? dataSources : [] }, rest);
    }
    function makeHealthcareRelation(entities) {
        return ({ entities: generatedEntities, relationType, confidenceScore, }) => ({
            relationType: relationType,
            confidenceScore,
            roles: generatedEntities.map((role) => ({
                entity: entities[parseHealthcareEntityIndex(role.ref)],
                name: role.role,
            })),
        });
    }
    return transformDocumentResults(docIds, results, {
        processSuccess: (_a) => {
            var { entities, relations } = _a, rest = tslib.__rest(_a, ["entities", "relations"]);
            const newEntities = entities.map(makeHealthcareEntity);
            return Object.assign({ entities: newEntities, entityRelations: relations.map(makeHealthcareRelation(newEntities)) }, rest);
        },
    });
}
/**
 * @internal
 */
function transformAnalyzeBatchResults(docIds, response = [], errors = []) {
    const errorMap = toIndexErrorMap(errors);
    return response.map((actionData, idx) => {
        const { lastUpdateDateTime: completedOn, actionName, kind: resultKind } = actionData;
        const error = errorMap.get(idx);
        switch (resultKind) {
            case "SentimentAnalysisLROResults": {
                const kind = "SentimentAnalysis";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: toSentimentAnalysisResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "EntityRecognitionLROResults": {
                const kind = "EntityRecognition";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind: "EntityRecognition", results: toEntityRecognitionResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "PiiEntityRecognitionLROResults": {
                const kind = "PiiEntityRecognition";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: toPiiEntityRecognitionResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "KeyPhraseExtractionLROResults": {
                const kind = "KeyPhraseExtraction";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: toKeyPhraseExtractionResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "EntityLinkingLROResults": {
                const kind = "EntityLinking";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: toEntityLinkingResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "HealthcareLROResults": {
                const kind = "Healthcare";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: toHealthcareResult(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "CustomEntityRecognitionLROResults": {
                const kind = "CustomEntityRecognition";
                if (actionData.status === "failed") {
                    return returnErrorCustomTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { deploymentName, projectName, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: transformDocumentResults(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { deploymentName,
                    projectName });
            }
            case "CustomSingleLabelClassificationLROResults": {
                const kind = "CustomSingleLabelClassification";
                if (actionData.status === "failed") {
                    return returnErrorCustomTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { deploymentName, projectName, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: transformDocumentResults(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { deploymentName,
                    projectName });
            }
            case "CustomMultiLabelClassificationLROResults": {
                const kind = "CustomMultiLabelClassification";
                if (actionData.status === "failed") {
                    return returnErrorCustomTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { deploymentName, projectName, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind, results: transformDocumentResults(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { deploymentName,
                    projectName });
            }
            case "ExtractiveSummarizationLROResults": {
                const kind = "ExtractiveSummarization";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind: "ExtractiveSummarization", results: transformDocumentResults(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            case "AbstractiveSummarizationLROResults": {
                const kind = "AbstractiveSummarization";
                if (actionData.status === "failed") {
                    return returnErrorTask(kind, error, completedOn);
                }
                const { results } = actionData;
                const { modelVersion, statistics } = results;
                return Object.assign(Object.assign(Object.assign({ kind: "AbstractiveSummarization", results: transformDocumentResults(docIds, results), completedOn }, (actionName ? { actionName } : {})), (statistics ? { statistics } : {})), { modelVersion });
            }
            default: {
                throw new Error(`Unsupported results kind: ${resultKind}`);
            }
        }
    });
}
/**
 * @internal
 * Transform a list of error into index and error Map
 */
function toIndexErrorMap(errors) {
    const errorMap = new Map();
    for (const error of errors) {
        const position = extractErrorPointerIndex(error);
        const errorWithoutTarget = tslib.__rest(error, ["target"]);
        errorMap.set(position, toTextAnalysisError(errorWithoutTarget));
    }
    return errorMap;
}
/**
 * Return the error for non-custom task
 *
 * @param kind - non custom task kind
 * @param error - error returned from the service
 * @param failedOn - the LastUpdateDateTime from the service
 * @returns - AnalyzeBatchResult with error
 */
function returnErrorTask(kind, error, failedOn) {
    if (!error) {
        throw new Error("Unexpected response from service - no errors for missing action results.");
    }
    return {
        kind,
        modelVersion: "",
        failedOn,
        error,
    };
}
/**
 * Return the error for non-custom task
 *
 * @param kind - non custom task kind
 * @param error - error returned from the service
 * @param failedOn - the LastUpdateDateTime from the service
 * @returns AnalyzeBatchResult for custom task with error
 */
function returnErrorCustomTask(kind, error, failedOn) {
    if (!error) {
        throw new Error("Unexpected response from service - no errors for missing action results.");
    }
    return {
        kind,
        projectName: "",
        deploymentName: "",
        failedOn,
        error,
    };
}

// Copyright (c) Microsoft Corporation.
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const jobStatusOperationSpec$1 = {
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeTextJobState,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    headerParameters: [accept],
    queryParameters: [top, skip, includeStatistics],
    serializer: serializer$2,
};
function addOnResponse(options, cb) {
    return Object.assign(Object.assign({}, options), { onResponse: (rawResponse, response, error) => {
            var _a;
            cb(rawResponse, response, error);
            (_a = options.onResponse) === null || _a === void 0 ? void 0 : _a.call(options, rawResponse, response, error);
        } });
}
function logWarnHeader(rawResponse) {
    const warnHeader = rawResponse.headers.get("warn-text");
    if (warnHeader) {
        warnHeader.split(";").map((x) => logger.warning(x));
    }
}
async function getRawResponse(getResponse, options) {
    let rawResponse;
    const flatResponse = await getResponse(addOnResponse(options, (response) => {
        rawResponse = response;
    }));
    return {
        flatResponse,
        rawResponse: {
            statusCode: rawResponse.status,
            headers: rawResponse.headers.toJSON(),
            body: rawResponse.parsedBody,
        },
    };
}
async function sendRequest(settings) {
    const { client, opOptions, path, spanStr, spec, tracing, httpMethod = "GET" } = settings;
    return tracing.withSpan(spanStr, opOptions, async (finalOptions) => throwError(getRawResponse((options) => client.sendOperationRequest({ options }, Object.assign(Object.assign({}, spec), { path,
        httpMethod })), finalOptions)));
}
/**
 * @internal
 */
function createSendPollRequest(settings) {
    const { client, options, tracing, spanStr } = settings;
    return async (path) => {
        return throwError(sendRequest({
            client,
            opOptions: addOnResponse(options, (_, response) => {
                const castResponse = response;
                if (castResponse.status.toLowerCase() === "partiallysucceeded") {
                    castResponse.status = "succeeded";
                }
            }),
            path,
            spanStr,
            spec: jobStatusOperationSpec$1,
            tracing,
        }));
    };
}
/**
 * @internal
 */
function createAnalyzeBatchLro(settings) {
    const { client, commonOptions, documents, initialRequestOptions, pollRequestOptions, tasks, tracing, } = settings;
    return {
        async sendInitialRequest() {
            return tracing.withSpan(`${clientName}.beginAnalyzeBatch`, addOnResponse(Object.assign(Object.assign({}, commonOptions), initialRequestOptions), logWarnHeader), async (finalOptions) => throwError(getRawResponse((paramOptions) => client.analyzeBatch({
                tasks,
                analysisInput: {
                    documents,
                },
                displayName: initialRequestOptions.displayName,
            }, paramOptions), finalOptions)));
        },
        sendPollRequest: createSendPollRequest({
            client,
            options: Object.assign(Object.assign({}, commonOptions), pollRequestOptions),
            spanStr: `${clientName}.beginAnalyzeBatch`,
            tracing,
        }),
    };
}
/**
 * @internal
 */
function getDocIDsFromState(serializedState) {
    try {
        const { docIds } = JSON.parse(serializedState).state;
        return docIds;
    }
    catch (e) {
        logger.error(`Document IDs are not found in the LRO's state. The results may not be ordered correctly.`);
        return [];
    }
}
/**
 * @internal
 */
function createCreateAnalyzeBatchPollerLro(settings) {
    const { client, options, tracing } = settings;
    return {
        async sendInitialRequest() {
            throw new Error(`The operation has already started`);
        },
        sendPollRequest: createSendPollRequest({
            client,
            options,
            spanStr: `${clientName}.beginAnalyzeBatch`,
            tracing,
        }),
    };
}
/**
 * @internal
 */
function processAnalyzeResult(options) {
    return () => {
        const { client, docIds, opOptions, tracing, state } = options;
        const pageURL = state.continuationToken;
        const pagedResult = {
            firstPageLink: pageURL,
            getPage: async (pageLink, maxPageSize) => {
                const response = await sendRequest({
                    client,
                    spec: jobStatusOperationSpec$1,
                    spanStr: `${clientName}.beginAnalyzeBatch`,
                    // if `top` is set to `undefined`, the default value will not be sent
                    // as part of the request.
                    opOptions: maxPageSize ? Object.assign(Object.assign({}, opOptions), { top: maxPageSize }) : opOptions,
                    path: pageLink,
                    tracing,
                });
                const flatResponse = response.flatResponse;
                return {
                    page: transformAnalyzeBatchResults(docIds, flatResponse.tasks.items, flatResponse.errors),
                    nextPageLink: flatResponse.nextLink,
                };
            },
        };
        return corePaging.getPagedAsyncIterator(pagedResult);
    };
}
/**
 * @internal
 */
function createUpdateAnalyzeState(docIds) {
    return (state, lastResponse) => {
        const { createdOn, modifiedOn, id, displayName, expiresOn, tasks, lastUpdateDateTime } = lastResponse.flatResponse;
        const mutableState = state;
        mutableState.createdOn = createdOn;
        // FIXME: remove this mitigation when the service API is fixed
        mutableState.modifiedOn = modifiedOn ? modifiedOn : new Date(lastUpdateDateTime);
        mutableState.expiresOn = expiresOn;
        mutableState.displayName = displayName;
        mutableState.id = id;
        mutableState.actionSucceededCount = tasks.completed;
        mutableState.actionFailedCount = tasks.failed;
        mutableState.actionInProgressCount = tasks.inProgress;
        if (mutableState.docIds === undefined && docIds !== undefined) {
            mutableState.docIds = docIds;
        }
    };
}
/**
 * @internal
 */
function createPollerWithCancellation(settings) {
    const { client, options, poller, id, tracing } = settings;
    return Object.assign(Object.assign({}, poller), { sendCancellationRequest: async () => {
            await tracing.withSpan(`${clientName}.beginAnalyzeBatch`, options, async (finalOptions) => throwError(getRawResponse((paramOptions) => client.analyzeText.cancelJob(id, paramOptions), finalOptions)));
        } });
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing AnalyzeText operations. */
class AnalyzeTextImpl {
    /**
     * Initialize a new instance of the class AnalyzeText class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are
     * succeeded, the job will transition to the succeeded state and results will be available for each
     * task.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    jobStatus(jobId, options) {
        return this.client.sendOperationRequest({ jobId, options }, jobStatusOperationSpec);
    }
    /**
     * Cancel a long-running Text Analysis job.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    cancelJob(jobId, options) {
        return this.client.sendOperationRequest({ jobId, options }, cancelJobOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const jobStatusOperationSpec = {
    path: "/analyze-text/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeTextJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [endpoint, jobId],
    headerParameters: [accept],
    serializer: serializer$1
};
const cancelJobOperationSpec = {
    path: "/analyze-text/jobs/{jobId}:cancel",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: AnalyzeTextCancelJobHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, jobId],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoint (e.g.,
     *                 https://<resource-name>.api.cognitiveservices.azure.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-language-text/1.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{Endpoint}/language" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2023-04-01";
        this.analyzeText = new AnalyzeTextImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Submit a collection of text documents for analysis.  Specify a single unique task to be executed
     * immediately.
     * @param body Collection of documents to analyze and a single task to execute.
     * @param options The options parameters.
     */
    analyze(body, options) {
        return this.sendOperationRequest({ body, options }, analyzeOperationSpec);
    }
    /**
     * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed
     * as a long-running operation.
     * @param body Collection of documents to analyze and one or more tasks to execute.
     * @param options The options parameters.
     */
    analyzeBatch(body, options) {
        return this.sendOperationRequest({ body, options }, analyzeBatchOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const analyzeOperationSpec = {
    path: "/:analyze-text",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AnalyzeTextTaskResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion, includeStatistics],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const analyzeBatchOperationSpec = {
    path: "/analyze-text/jobs",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeBatchHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * The programmatic identifier of the textAnalyticsAzureKeyCredentialPolicy.
 */
const textAnalyticsAzureKeyCredentialPolicyName = "textAnalyticsAzureKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 * @internal
 */
function textAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        name: textAnalyticsAzureKeyCredentialPolicyName,
        sendRequest(request, next) {
            request.headers.set(API_KEY_HEADER_NAME, credential.key);
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * A client for interacting with the text analysis features in Azure Cognitive
 * Language Service.
 *
 * The client needs the endpoint of a Language resource and an authentication
 * method such as an API key or AAD. The API key and endpoint can be found in
 * the Language resource page in the Azure portal. They will be located in the
 * resource's Keys and Endpoint page, under Resource Management.
 *
 * ### Examples for authentication:
 *
 * #### API Key
 *
 * ```js
 * import { TextAnalysisClient, AzureKeyCredential } from "@azure/ai-language-text";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new TextAnalysisClient(endpoint, credential);
 * ```
 *
 * #### Azure Active Directory
 *
 * See the [`@azure/identity`](https://npmjs.com/package/\@azure/identity)
 * package for more information about authenticating with Azure Active Directory.
 *
 * ```js
 * import { TextAnalysisClient } from "@azure/ai-language-text";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new TextAnalysisClient(endpoint, credential);
 * ```
 */
class TextAnalysisClient {
    constructor(endpointUrl, credential, options = {}) {
        const { defaultCountryHint = "us", defaultLanguage = "en", serviceVersion } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage", "serviceVersion"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const internalPipelineOptions = Object.assign(Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"],
            },
        }), { apiVersion: serviceVersion });
        this._client = new GeneratedClient(endpointUrl, internalPipelineOptions);
        const authPolicy = coreAuth.isTokenCredential(credential)
            ? coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE })
            : textAnalyticsAzureKeyCredentialPolicy(credential);
        this._client.pipeline.addPolicy(authPolicy);
        this._tracing = coreTracing.createTracingClient({
            packageName: "@azure/ai-language-text",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    // implementation
    async analyze(actionName, documents, languageOrCountryHintOrOptions, options) {
        let realOptions;
        if (documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        let realInputs;
        if (isStringArray(documents)) {
            if (actionName === "LanguageDetection") {
                realInputs = convertToLanguageDetectionInput(documents, typeof languageOrCountryHintOrOptions === "string"
                    ? languageOrCountryHintOrOptions
                    : this.defaultCountryHint);
            }
            else {
                realInputs = convertToTextDocumentInput(documents, typeof languageOrCountryHintOrOptions === "string"
                    ? languageOrCountryHintOrOptions
                    : this.defaultLanguage);
            }
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions =
                languageOrCountryHintOrOptions || {};
        }
        const { options: operationOptions, rest: action } = getOperationOptions(realOptions);
        return this._tracing.withSpan("TextAnalysisClient.analyze", operationOptions, async (updatedOptions) => throwError(this._client
            .analyze({
            kind: actionName,
            analysisInput: {
                documents: realInputs,
            },
            parameters: action,
        }, updatedOptions)
            .then((result) => transformActionResult(actionName, realInputs.map(({ id }) => id), result))));
    }
    // implementation
    async beginAnalyzeBatch(actions, documents, languageOrOptions, options = {}) {
        var _a;
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const languageCode = (_a = languageOrOptions) !== null && _a !== void 0 ? _a : this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, languageCode);
            realOptions = options;
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions;
        }
        const realActions = actions.map((_a) => {
            var { kind, actionName } = _a, rest = tslib.__rest(_a, ["kind", "actionName"]);
            return ({
                kind,
                actionName,
                parameters: rest,
            });
        });
        const { includeStatistics, updateIntervalInMs, displayName } = realOptions, rest = tslib.__rest(realOptions, ["includeStatistics", "updateIntervalInMs", "displayName"]);
        const lro = createAnalyzeBatchLro({
            client: this._client,
            commonOptions: rest,
            documents: realInputs,
            initialRequestOptions: { displayName },
            pollRequestOptions: { includeStatistics },
            tasks: realActions,
            tracing: this._tracing,
        });
        const docIds = realInputs.map(({ id }) => id);
        const state = { continuationToken: "" };
        const poller = await coreLro.createHttpPoller(lro, {
            intervalInMs: updateIntervalInMs,
            processResult: processAnalyzeResult({
                client: this._client,
                tracing: this._tracing,
                docIds,
                opOptions: Object.assign(Object.assign({}, rest), { includeStatistics }),
                state,
            }),
            updateState: createUpdateAnalyzeState(docIds),
            withOperationLocation(operationLocation) {
                state.continuationToken = operationLocation;
            },
        });
        await poller.poll();
        const id = poller.getOperationState().id;
        return createPollerWithCancellation({
            id,
            client: this._client,
            options,
            poller,
            tracing: this._tracing,
        });
    }
    // implementation
    async restoreAnalyzeBatchPoller(serializedState, options = {}) {
        const { includeStatistics, updateIntervalInMs } = options, rest = tslib.__rest(options, ["includeStatistics", "updateIntervalInMs"]);
        const docIds = getDocIDsFromState(serializedState);
        const lro = createCreateAnalyzeBatchPollerLro({
            client: this._client,
            options: Object.assign(Object.assign({}, rest), { includeStatistics }),
            tracing: this._tracing,
        });
        const state = { continuationToken: "" };
        const poller = await coreLro.createHttpPoller(lro, {
            intervalInMs: updateIntervalInMs,
            restoreFrom: serializedState,
            processResult: processAnalyzeResult({
                client: this._client,
                tracing: this._tracing,
                docIds,
                opOptions: Object.assign(Object.assign({}, rest), { includeStatistics }),
                state,
            }),
            updateState: createUpdateAnalyzeState(),
            withOperationLocation(operationLocation) {
                state.continuationToken = operationLocation;
            },
        });
        await poller.poll();
        const id = poller.getOperationState().id;
        return createPollerWithCancellation({
            id,
            client: this._client,
            options,
            poller,
            tracing: this._tracing,
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AnalyzeTextTaskKind} that the service accepts. */
var KnownAnalyzeTextTaskKind;
(function (KnownAnalyzeTextTaskKind) {
    /** SentimentAnalysis */
    KnownAnalyzeTextTaskKind["SentimentAnalysis"] = "SentimentAnalysis";
    /** EntityRecognition */
    KnownAnalyzeTextTaskKind["EntityRecognition"] = "EntityRecognition";
    /** PiiEntityRecognition */
    KnownAnalyzeTextTaskKind["PiiEntityRecognition"] = "PiiEntityRecognition";
    /** KeyPhraseExtraction */
    KnownAnalyzeTextTaskKind["KeyPhraseExtraction"] = "KeyPhraseExtraction";
    /** LanguageDetection */
    KnownAnalyzeTextTaskKind["LanguageDetection"] = "LanguageDetection";
    /** EntityLinking */
    KnownAnalyzeTextTaskKind["EntityLinking"] = "EntityLinking";
})(KnownAnalyzeTextTaskKind || (KnownAnalyzeTextTaskKind = {}));
/** Known values of {@link AnalyzeTextTaskResultsKind} that the service accepts. */
var KnownAnalyzeTextTaskResultsKind;
(function (KnownAnalyzeTextTaskResultsKind) {
    /** SentimentAnalysisResults */
    KnownAnalyzeTextTaskResultsKind["SentimentAnalysisResults"] = "SentimentAnalysisResults";
    /** EntityRecognitionResults */
    KnownAnalyzeTextTaskResultsKind["EntityRecognitionResults"] = "EntityRecognitionResults";
    /** PiiEntityRecognitionResults */
    KnownAnalyzeTextTaskResultsKind["PiiEntityRecognitionResults"] = "PiiEntityRecognitionResults";
    /** KeyPhraseExtractionResults */
    KnownAnalyzeTextTaskResultsKind["KeyPhraseExtractionResults"] = "KeyPhraseExtractionResults";
    /** LanguageDetectionResults */
    KnownAnalyzeTextTaskResultsKind["LanguageDetectionResults"] = "LanguageDetectionResults";
    /** EntityLinkingResults */
    KnownAnalyzeTextTaskResultsKind["EntityLinkingResults"] = "EntityLinkingResults";
})(KnownAnalyzeTextTaskResultsKind || (KnownAnalyzeTextTaskResultsKind = {}));
/** Known values of {@link ErrorCode} that the service accepts. */
exports.KnownErrorCode = void 0;
(function (KnownErrorCode) {
    /** InvalidRequest */
    KnownErrorCode["InvalidRequest"] = "InvalidRequest";
    /** InvalidArgument */
    KnownErrorCode["InvalidArgument"] = "InvalidArgument";
    /** Unauthorized */
    KnownErrorCode["Unauthorized"] = "Unauthorized";
    /** Forbidden */
    KnownErrorCode["Forbidden"] = "Forbidden";
    /** NotFound */
    KnownErrorCode["NotFound"] = "NotFound";
    /** ProjectNotFound */
    KnownErrorCode["ProjectNotFound"] = "ProjectNotFound";
    /** OperationNotFound */
    KnownErrorCode["OperationNotFound"] = "OperationNotFound";
    /** AzureCognitiveSearchNotFound */
    KnownErrorCode["AzureCognitiveSearchNotFound"] = "AzureCognitiveSearchNotFound";
    /** AzureCognitiveSearchIndexNotFound */
    KnownErrorCode["AzureCognitiveSearchIndexNotFound"] = "AzureCognitiveSearchIndexNotFound";
    /** TooManyRequests */
    KnownErrorCode["TooManyRequests"] = "TooManyRequests";
    /** AzureCognitiveSearchThrottling */
    KnownErrorCode["AzureCognitiveSearchThrottling"] = "AzureCognitiveSearchThrottling";
    /** AzureCognitiveSearchIndexLimitReached */
    KnownErrorCode["AzureCognitiveSearchIndexLimitReached"] = "AzureCognitiveSearchIndexLimitReached";
    /** InternalServerError */
    KnownErrorCode["InternalServerError"] = "InternalServerError";
    /** ServiceUnavailable */
    KnownErrorCode["ServiceUnavailable"] = "ServiceUnavailable";
    /** Timeout */
    KnownErrorCode["Timeout"] = "Timeout";
    /** QuotaExceeded */
    KnownErrorCode["QuotaExceeded"] = "QuotaExceeded";
    /** Conflict */
    KnownErrorCode["Conflict"] = "Conflict";
    /** Warning */
    KnownErrorCode["Warning"] = "Warning";
})(exports.KnownErrorCode || (exports.KnownErrorCode = {}));
/** Known values of {@link InnerErrorCode} that the service accepts. */
exports.KnownInnerErrorCode = void 0;
(function (KnownInnerErrorCode) {
    /** InvalidRequest */
    KnownInnerErrorCode["InvalidRequest"] = "InvalidRequest";
    /** InvalidParameterValue */
    KnownInnerErrorCode["InvalidParameterValue"] = "InvalidParameterValue";
    /** KnowledgeBaseNotFound */
    KnownInnerErrorCode["KnowledgeBaseNotFound"] = "KnowledgeBaseNotFound";
    /** AzureCognitiveSearchNotFound */
    KnownInnerErrorCode["AzureCognitiveSearchNotFound"] = "AzureCognitiveSearchNotFound";
    /** AzureCognitiveSearchThrottling */
    KnownInnerErrorCode["AzureCognitiveSearchThrottling"] = "AzureCognitiveSearchThrottling";
    /** ExtractionFailure */
    KnownInnerErrorCode["ExtractionFailure"] = "ExtractionFailure";
    /** InvalidRequestBodyFormat */
    KnownInnerErrorCode["InvalidRequestBodyFormat"] = "InvalidRequestBodyFormat";
    /** EmptyRequest */
    KnownInnerErrorCode["EmptyRequest"] = "EmptyRequest";
    /** MissingInputDocuments */
    KnownInnerErrorCode["MissingInputDocuments"] = "MissingInputDocuments";
    /** InvalidDocument */
    KnownInnerErrorCode["InvalidDocument"] = "InvalidDocument";
    /** ModelVersionIncorrect */
    KnownInnerErrorCode["ModelVersionIncorrect"] = "ModelVersionIncorrect";
    /** InvalidDocumentBatch */
    KnownInnerErrorCode["InvalidDocumentBatch"] = "InvalidDocumentBatch";
    /** UnsupportedLanguageCode */
    KnownInnerErrorCode["UnsupportedLanguageCode"] = "UnsupportedLanguageCode";
    /** InvalidCountryHint */
    KnownInnerErrorCode["InvalidCountryHint"] = "InvalidCountryHint";
})(exports.KnownInnerErrorCode || (exports.KnownInnerErrorCode = {}));
/** Known values of {@link AnalyzeTextLROTaskKind} that the service accepts. */
var KnownAnalyzeTextLROTaskKind;
(function (KnownAnalyzeTextLROTaskKind) {
    /** SentimentAnalysis */
    KnownAnalyzeTextLROTaskKind["SentimentAnalysis"] = "SentimentAnalysis";
    /** EntityRecognition */
    KnownAnalyzeTextLROTaskKind["EntityRecognition"] = "EntityRecognition";
    /** PiiEntityRecognition */
    KnownAnalyzeTextLROTaskKind["PiiEntityRecognition"] = "PiiEntityRecognition";
    /** KeyPhraseExtraction */
    KnownAnalyzeTextLROTaskKind["KeyPhraseExtraction"] = "KeyPhraseExtraction";
    /** EntityLinking */
    KnownAnalyzeTextLROTaskKind["EntityLinking"] = "EntityLinking";
    /** Healthcare */
    KnownAnalyzeTextLROTaskKind["Healthcare"] = "Healthcare";
    /** ExtractiveSummarization */
    KnownAnalyzeTextLROTaskKind["ExtractiveSummarization"] = "ExtractiveSummarization";
    /** CustomEntityRecognition */
    KnownAnalyzeTextLROTaskKind["CustomEntityRecognition"] = "CustomEntityRecognition";
    /** CustomSingleLabelClassification */
    KnownAnalyzeTextLROTaskKind["CustomSingleLabelClassification"] = "CustomSingleLabelClassification";
    /** CustomMultiLabelClassification */
    KnownAnalyzeTextLROTaskKind["CustomMultiLabelClassification"] = "CustomMultiLabelClassification";
    /** AbstractiveSummarization */
    KnownAnalyzeTextLROTaskKind["AbstractiveSummarization"] = "AbstractiveSummarization";
})(KnownAnalyzeTextLROTaskKind || (KnownAnalyzeTextLROTaskKind = {}));
/** Known values of {@link OperationStatus} that the service accepts. */
var KnownOperationStatus;
(function (KnownOperationStatus) {
    /** NotStarted */
    KnownOperationStatus["NotStarted"] = "notStarted";
    /** Running */
    KnownOperationStatus["Running"] = "running";
    /** Succeeded */
    KnownOperationStatus["Succeeded"] = "succeeded";
    /** PartiallyCompleted */
    KnownOperationStatus["PartiallyCompleted"] = "partiallyCompleted";
    /** Failed */
    KnownOperationStatus["Failed"] = "failed";
    /** Cancelled */
    KnownOperationStatus["Cancelled"] = "cancelled";
    /** Cancelling */
    KnownOperationStatus["Cancelling"] = "cancelling";
})(KnownOperationStatus || (KnownOperationStatus = {}));
/** Known values of {@link AnalyzeTextLROResultsKind} that the service accepts. */
var KnownAnalyzeTextLROResultsKind;
(function (KnownAnalyzeTextLROResultsKind) {
    /** SentimentAnalysisLROResults */
    KnownAnalyzeTextLROResultsKind["SentimentAnalysisLROResults"] = "SentimentAnalysisLROResults";
    /** EntityRecognitionLROResults */
    KnownAnalyzeTextLROResultsKind["EntityRecognitionLROResults"] = "EntityRecognitionLROResults";
    /** PiiEntityRecognitionLROResults */
    KnownAnalyzeTextLROResultsKind["PiiEntityRecognitionLROResults"] = "PiiEntityRecognitionLROResults";
    /** KeyPhraseExtractionLROResults */
    KnownAnalyzeTextLROResultsKind["KeyPhraseExtractionLROResults"] = "KeyPhraseExtractionLROResults";
    /** EntityLinkingLROResults */
    KnownAnalyzeTextLROResultsKind["EntityLinkingLROResults"] = "EntityLinkingLROResults";
    /** HealthcareLROResults */
    KnownAnalyzeTextLROResultsKind["HealthcareLROResults"] = "HealthcareLROResults";
    /** ExtractiveSummarizationLROResults */
    KnownAnalyzeTextLROResultsKind["ExtractiveSummarizationLROResults"] = "ExtractiveSummarizationLROResults";
    /** CustomEntityRecognitionLROResults */
    KnownAnalyzeTextLROResultsKind["CustomEntityRecognitionLROResults"] = "CustomEntityRecognitionLROResults";
    /** CustomSingleLabelClassificationLROResults */
    KnownAnalyzeTextLROResultsKind["CustomSingleLabelClassificationLROResults"] = "CustomSingleLabelClassificationLROResults";
    /** CustomMultiLabelClassificationLROResults */
    KnownAnalyzeTextLROResultsKind["CustomMultiLabelClassificationLROResults"] = "CustomMultiLabelClassificationLROResults";
    /** AbstractiveSummarizationLROResults */
    KnownAnalyzeTextLROResultsKind["AbstractiveSummarizationLROResults"] = "AbstractiveSummarizationLROResults";
})(KnownAnalyzeTextLROResultsKind || (KnownAnalyzeTextLROResultsKind = {}));
/** Known values of {@link State} that the service accepts. */
var KnownState;
(function (KnownState) {
    /** NotStarted */
    KnownState["NotStarted"] = "notStarted";
    /** Running */
    KnownState["Running"] = "running";
    /** Succeeded */
    KnownState["Succeeded"] = "succeeded";
    /** Failed */
    KnownState["Failed"] = "failed";
    /** Cancelled */
    KnownState["Cancelled"] = "cancelled";
    /** Cancelling */
    KnownState["Cancelling"] = "cancelling";
})(KnownState || (KnownState = {}));
/** Known values of {@link StringIndexType} that the service accepts. */
exports.KnownStringIndexType = void 0;
(function (KnownStringIndexType) {
    /** Returned offset and length values will correspond to TextElements (Graphemes and Grapheme clusters) confirming to the Unicode 8.0.0 standard. Use this option if your application is written in .Net Framework or .Net Core and you will be using StringInfo. */
    KnownStringIndexType["TextElementsV8"] = "TextElements_v8";
    /** Returned offset and length values will correspond to Unicode code points. Use this option if your application is written in a language that support Unicode, for example Python. */
    KnownStringIndexType["UnicodeCodePoint"] = "UnicodeCodePoint";
    /** Returned offset and length values will correspond to UTF-16 code units. Use this option if your application is written in a language that support Unicode, for example Java, JavaScript. */
    KnownStringIndexType["Utf16CodeUnit"] = "Utf16CodeUnit";
})(exports.KnownStringIndexType || (exports.KnownStringIndexType = {}));
/** Known values of {@link PiiEntityDomain} that the service accepts. */
exports.KnownPiiEntityDomain = void 0;
(function (KnownPiiEntityDomain) {
    /** Indicates that entities in the Personal Health Information domain should be redacted. */
    KnownPiiEntityDomain["Phi"] = "phi";
    /** Indicates that no domain is specified. */
    KnownPiiEntityDomain["None"] = "none";
})(exports.KnownPiiEntityDomain || (exports.KnownPiiEntityDomain = {}));
/** Known values of {@link PiiEntityCategory} that the service accepts. */
exports.KnownPiiEntityCategory = void 0;
(function (KnownPiiEntityCategory) {
    /** ABARoutingNumber */
    KnownPiiEntityCategory["ABARoutingNumber"] = "ABARoutingNumber";
    /** ARNationalIdentityNumber */
    KnownPiiEntityCategory["ARNationalIdentityNumber"] = "ARNationalIdentityNumber";
    /** AUBankAccountNumber */
    KnownPiiEntityCategory["AUBankAccountNumber"] = "AUBankAccountNumber";
    /** AUDriversLicenseNumber */
    KnownPiiEntityCategory["AUDriversLicenseNumber"] = "AUDriversLicenseNumber";
    /** AUMedicalAccountNumber */
    KnownPiiEntityCategory["AUMedicalAccountNumber"] = "AUMedicalAccountNumber";
    /** AUPassportNumber */
    KnownPiiEntityCategory["AUPassportNumber"] = "AUPassportNumber";
    /** AUTaxFileNumber */
    KnownPiiEntityCategory["AUTaxFileNumber"] = "AUTaxFileNumber";
    /** AUBusinessNumber */
    KnownPiiEntityCategory["AUBusinessNumber"] = "AUBusinessNumber";
    /** AUCompanyNumber */
    KnownPiiEntityCategory["AUCompanyNumber"] = "AUCompanyNumber";
    /** ATIdentityCard */
    KnownPiiEntityCategory["ATIdentityCard"] = "ATIdentityCard";
    /** ATTaxIdentificationNumber */
    KnownPiiEntityCategory["ATTaxIdentificationNumber"] = "ATTaxIdentificationNumber";
    /** ATValueAddedTaxNumber */
    KnownPiiEntityCategory["ATValueAddedTaxNumber"] = "ATValueAddedTaxNumber";
    /** AzureDocumentDBAuthKey */
    KnownPiiEntityCategory["AzureDocumentDBAuthKey"] = "AzureDocumentDBAuthKey";
    /** AzureIaasDatabaseConnectionAndSQLString */
    KnownPiiEntityCategory["AzureIaasDatabaseConnectionAndSQLString"] = "AzureIAASDatabaseConnectionAndSQLString";
    /** AzureIoTConnectionString */
    KnownPiiEntityCategory["AzureIoTConnectionString"] = "AzureIoTConnectionString";
    /** AzurePublishSettingPassword */
    KnownPiiEntityCategory["AzurePublishSettingPassword"] = "AzurePublishSettingPassword";
    /** AzureRedisCacheString */
    KnownPiiEntityCategory["AzureRedisCacheString"] = "AzureRedisCacheString";
    /** AzureSAS */
    KnownPiiEntityCategory["AzureSAS"] = "AzureSAS";
    /** AzureServiceBusString */
    KnownPiiEntityCategory["AzureServiceBusString"] = "AzureServiceBusString";
    /** AzureStorageAccountKey */
    KnownPiiEntityCategory["AzureStorageAccountKey"] = "AzureStorageAccountKey";
    /** AzureStorageAccountGeneric */
    KnownPiiEntityCategory["AzureStorageAccountGeneric"] = "AzureStorageAccountGeneric";
    /** BENationalNumber */
    KnownPiiEntityCategory["BENationalNumber"] = "BENationalNumber";
    /** BENationalNumberV2 */
    KnownPiiEntityCategory["BENationalNumberV2"] = "BENationalNumberV2";
    /** BEValueAddedTaxNumber */
    KnownPiiEntityCategory["BEValueAddedTaxNumber"] = "BEValueAddedTaxNumber";
    /** BrcpfNumber */
    KnownPiiEntityCategory["BrcpfNumber"] = "BRCPFNumber";
    /** BRLegalEntityNumber */
    KnownPiiEntityCategory["BRLegalEntityNumber"] = "BRLegalEntityNumber";
    /** BRNationalIdrg */
    KnownPiiEntityCategory["BRNationalIdrg"] = "BRNationalIDRG";
    /** BGUniformCivilNumber */
    KnownPiiEntityCategory["BGUniformCivilNumber"] = "BGUniformCivilNumber";
    /** CABankAccountNumber */
    KnownPiiEntityCategory["CABankAccountNumber"] = "CABankAccountNumber";
    /** CADriversLicenseNumber */
    KnownPiiEntityCategory["CADriversLicenseNumber"] = "CADriversLicenseNumber";
    /** CAHealthServiceNumber */
    KnownPiiEntityCategory["CAHealthServiceNumber"] = "CAHealthServiceNumber";
    /** CAPassportNumber */
    KnownPiiEntityCategory["CAPassportNumber"] = "CAPassportNumber";
    /** CAPersonalHealthIdentification */
    KnownPiiEntityCategory["CAPersonalHealthIdentification"] = "CAPersonalHealthIdentification";
    /** CASocialInsuranceNumber */
    KnownPiiEntityCategory["CASocialInsuranceNumber"] = "CASocialInsuranceNumber";
    /** CLIdentityCardNumber */
    KnownPiiEntityCategory["CLIdentityCardNumber"] = "CLIdentityCardNumber";
    /** CNResidentIdentityCardNumber */
    KnownPiiEntityCategory["CNResidentIdentityCardNumber"] = "CNResidentIdentityCardNumber";
    /** CreditCardNumber */
    KnownPiiEntityCategory["CreditCardNumber"] = "CreditCardNumber";
    /** HRIdentityCardNumber */
    KnownPiiEntityCategory["HRIdentityCardNumber"] = "HRIdentityCardNumber";
    /** HRNationalIDNumber */
    KnownPiiEntityCategory["HRNationalIDNumber"] = "HRNationalIDNumber";
    /** HRPersonalIdentificationNumber */
    KnownPiiEntityCategory["HRPersonalIdentificationNumber"] = "HRPersonalIdentificationNumber";
    /** HRPersonalIdentificationOIBNumberV2 */
    KnownPiiEntityCategory["HRPersonalIdentificationOIBNumberV2"] = "HRPersonalIdentificationOIBNumberV2";
    /** CYIdentityCard */
    KnownPiiEntityCategory["CYIdentityCard"] = "CYIdentityCard";
    /** CYTaxIdentificationNumber */
    KnownPiiEntityCategory["CYTaxIdentificationNumber"] = "CYTaxIdentificationNumber";
    /** CZPersonalIdentityNumber */
    KnownPiiEntityCategory["CZPersonalIdentityNumber"] = "CZPersonalIdentityNumber";
    /** CZPersonalIdentityV2 */
    KnownPiiEntityCategory["CZPersonalIdentityV2"] = "CZPersonalIdentityV2";
    /** DKPersonalIdentificationNumber */
    KnownPiiEntityCategory["DKPersonalIdentificationNumber"] = "DKPersonalIdentificationNumber";
    /** DKPersonalIdentificationV2 */
    KnownPiiEntityCategory["DKPersonalIdentificationV2"] = "DKPersonalIdentificationV2";
    /** DrugEnforcementAgencyNumber */
    KnownPiiEntityCategory["DrugEnforcementAgencyNumber"] = "DrugEnforcementAgencyNumber";
    /** EEPersonalIdentificationCode */
    KnownPiiEntityCategory["EEPersonalIdentificationCode"] = "EEPersonalIdentificationCode";
    /** EUDebitCardNumber */
    KnownPiiEntityCategory["EUDebitCardNumber"] = "EUDebitCardNumber";
    /** EUDriversLicenseNumber */
    KnownPiiEntityCategory["EUDriversLicenseNumber"] = "EUDriversLicenseNumber";
    /** EugpsCoordinates */
    KnownPiiEntityCategory["EugpsCoordinates"] = "EUGPSCoordinates";
    /** EUNationalIdentificationNumber */
    KnownPiiEntityCategory["EUNationalIdentificationNumber"] = "EUNationalIdentificationNumber";
    /** EUPassportNumber */
    KnownPiiEntityCategory["EUPassportNumber"] = "EUPassportNumber";
    /** EUSocialSecurityNumber */
    KnownPiiEntityCategory["EUSocialSecurityNumber"] = "EUSocialSecurityNumber";
    /** EUTaxIdentificationNumber */
    KnownPiiEntityCategory["EUTaxIdentificationNumber"] = "EUTaxIdentificationNumber";
    /** FIEuropeanHealthNumber */
    KnownPiiEntityCategory["FIEuropeanHealthNumber"] = "FIEuropeanHealthNumber";
    /** FINationalID */
    KnownPiiEntityCategory["FINationalID"] = "FINationalID";
    /** FINationalIDV2 */
    KnownPiiEntityCategory["FINationalIDV2"] = "FINationalIDV2";
    /** FIPassportNumber */
    KnownPiiEntityCategory["FIPassportNumber"] = "FIPassportNumber";
    /** FRDriversLicenseNumber */
    KnownPiiEntityCategory["FRDriversLicenseNumber"] = "FRDriversLicenseNumber";
    /** FRHealthInsuranceNumber */
    KnownPiiEntityCategory["FRHealthInsuranceNumber"] = "FRHealthInsuranceNumber";
    /** FRNationalID */
    KnownPiiEntityCategory["FRNationalID"] = "FRNationalID";
    /** FRPassportNumber */
    KnownPiiEntityCategory["FRPassportNumber"] = "FRPassportNumber";
    /** FRSocialSecurityNumber */
    KnownPiiEntityCategory["FRSocialSecurityNumber"] = "FRSocialSecurityNumber";
    /** FRTaxIdentificationNumber */
    KnownPiiEntityCategory["FRTaxIdentificationNumber"] = "FRTaxIdentificationNumber";
    /** FRValueAddedTaxNumber */
    KnownPiiEntityCategory["FRValueAddedTaxNumber"] = "FRValueAddedTaxNumber";
    /** DEDriversLicenseNumber */
    KnownPiiEntityCategory["DEDriversLicenseNumber"] = "DEDriversLicenseNumber";
    /** DEPassportNumber */
    KnownPiiEntityCategory["DEPassportNumber"] = "DEPassportNumber";
    /** DEIdentityCardNumber */
    KnownPiiEntityCategory["DEIdentityCardNumber"] = "DEIdentityCardNumber";
    /** DETaxIdentificationNumber */
    KnownPiiEntityCategory["DETaxIdentificationNumber"] = "DETaxIdentificationNumber";
    /** DEValueAddedNumber */
    KnownPiiEntityCategory["DEValueAddedNumber"] = "DEValueAddedNumber";
    /** GRNationalIDCard */
    KnownPiiEntityCategory["GRNationalIDCard"] = "GRNationalIDCard";
    /** GRNationalIDV2 */
    KnownPiiEntityCategory["GRNationalIDV2"] = "GRNationalIDV2";
    /** GRTaxIdentificationNumber */
    KnownPiiEntityCategory["GRTaxIdentificationNumber"] = "GRTaxIdentificationNumber";
    /** HKIdentityCardNumber */
    KnownPiiEntityCategory["HKIdentityCardNumber"] = "HKIdentityCardNumber";
    /** HUValueAddedNumber */
    KnownPiiEntityCategory["HUValueAddedNumber"] = "HUValueAddedNumber";
    /** HUPersonalIdentificationNumber */
    KnownPiiEntityCategory["HUPersonalIdentificationNumber"] = "HUPersonalIdentificationNumber";
    /** HUTaxIdentificationNumber */
    KnownPiiEntityCategory["HUTaxIdentificationNumber"] = "HUTaxIdentificationNumber";
    /** INPermanentAccount */
    KnownPiiEntityCategory["INPermanentAccount"] = "INPermanentAccount";
    /** INUniqueIdentificationNumber */
    KnownPiiEntityCategory["INUniqueIdentificationNumber"] = "INUniqueIdentificationNumber";
    /** IDIdentityCardNumber */
    KnownPiiEntityCategory["IDIdentityCardNumber"] = "IDIdentityCardNumber";
    /** InternationalBankingAccountNumber */
    KnownPiiEntityCategory["InternationalBankingAccountNumber"] = "InternationalBankingAccountNumber";
    /** IEPersonalPublicServiceNumber */
    KnownPiiEntityCategory["IEPersonalPublicServiceNumber"] = "IEPersonalPublicServiceNumber";
    /** IEPersonalPublicServiceNumberV2 */
    KnownPiiEntityCategory["IEPersonalPublicServiceNumberV2"] = "IEPersonalPublicServiceNumberV2";
    /** ILBankAccountNumber */
    KnownPiiEntityCategory["ILBankAccountNumber"] = "ILBankAccountNumber";
    /** ILNationalID */
    KnownPiiEntityCategory["ILNationalID"] = "ILNationalID";
    /** ITDriversLicenseNumber */
    KnownPiiEntityCategory["ITDriversLicenseNumber"] = "ITDriversLicenseNumber";
    /** ITFiscalCode */
    KnownPiiEntityCategory["ITFiscalCode"] = "ITFiscalCode";
    /** ITValueAddedTaxNumber */
    KnownPiiEntityCategory["ITValueAddedTaxNumber"] = "ITValueAddedTaxNumber";
    /** JPBankAccountNumber */
    KnownPiiEntityCategory["JPBankAccountNumber"] = "JPBankAccountNumber";
    /** JPDriversLicenseNumber */
    KnownPiiEntityCategory["JPDriversLicenseNumber"] = "JPDriversLicenseNumber";
    /** JPPassportNumber */
    KnownPiiEntityCategory["JPPassportNumber"] = "JPPassportNumber";
    /** JPResidentRegistrationNumber */
    KnownPiiEntityCategory["JPResidentRegistrationNumber"] = "JPResidentRegistrationNumber";
    /** JPSocialInsuranceNumber */
    KnownPiiEntityCategory["JPSocialInsuranceNumber"] = "JPSocialInsuranceNumber";
    /** JPMyNumberCorporate */
    KnownPiiEntityCategory["JPMyNumberCorporate"] = "JPMyNumberCorporate";
    /** JPMyNumberPersonal */
    KnownPiiEntityCategory["JPMyNumberPersonal"] = "JPMyNumberPersonal";
    /** JPResidenceCardNumber */
    KnownPiiEntityCategory["JPResidenceCardNumber"] = "JPResidenceCardNumber";
    /** LVPersonalCode */
    KnownPiiEntityCategory["LVPersonalCode"] = "LVPersonalCode";
    /** LTPersonalCode */
    KnownPiiEntityCategory["LTPersonalCode"] = "LTPersonalCode";
    /** LUNationalIdentificationNumberNatural */
    KnownPiiEntityCategory["LUNationalIdentificationNumberNatural"] = "LUNationalIdentificationNumberNatural";
    /** LUNationalIdentificationNumberNonNatural */
    KnownPiiEntityCategory["LUNationalIdentificationNumberNonNatural"] = "LUNationalIdentificationNumberNonNatural";
    /** MYIdentityCardNumber */
    KnownPiiEntityCategory["MYIdentityCardNumber"] = "MYIdentityCardNumber";
    /** MTIdentityCardNumber */
    KnownPiiEntityCategory["MTIdentityCardNumber"] = "MTIdentityCardNumber";
    /** MTTaxIDNumber */
    KnownPiiEntityCategory["MTTaxIDNumber"] = "MTTaxIDNumber";
    /** NLCitizensServiceNumber */
    KnownPiiEntityCategory["NLCitizensServiceNumber"] = "NLCitizensServiceNumber";
    /** NLCitizensServiceNumberV2 */
    KnownPiiEntityCategory["NLCitizensServiceNumberV2"] = "NLCitizensServiceNumberV2";
    /** NLTaxIdentificationNumber */
    KnownPiiEntityCategory["NLTaxIdentificationNumber"] = "NLTaxIdentificationNumber";
    /** NLValueAddedTaxNumber */
    KnownPiiEntityCategory["NLValueAddedTaxNumber"] = "NLValueAddedTaxNumber";
    /** NZBankAccountNumber */
    KnownPiiEntityCategory["NZBankAccountNumber"] = "NZBankAccountNumber";
    /** NZDriversLicenseNumber */
    KnownPiiEntityCategory["NZDriversLicenseNumber"] = "NZDriversLicenseNumber";
    /** NZInlandRevenueNumber */
    KnownPiiEntityCategory["NZInlandRevenueNumber"] = "NZInlandRevenueNumber";
    /** NZMinistryOfHealthNumber */
    KnownPiiEntityCategory["NZMinistryOfHealthNumber"] = "NZMinistryOfHealthNumber";
    /** NZSocialWelfareNumber */
    KnownPiiEntityCategory["NZSocialWelfareNumber"] = "NZSocialWelfareNumber";
    /** NOIdentityNumber */
    KnownPiiEntityCategory["NOIdentityNumber"] = "NOIdentityNumber";
    /** PHUnifiedMultiPurposeIDNumber */
    KnownPiiEntityCategory["PHUnifiedMultiPurposeIDNumber"] = "PHUnifiedMultiPurposeIDNumber";
    /** PLIdentityCard */
    KnownPiiEntityCategory["PLIdentityCard"] = "PLIdentityCard";
    /** PLNationalID */
    KnownPiiEntityCategory["PLNationalID"] = "PLNationalID";
    /** PLNationalIDV2 */
    KnownPiiEntityCategory["PLNationalIDV2"] = "PLNationalIDV2";
    /** PLPassportNumber */
    KnownPiiEntityCategory["PLPassportNumber"] = "PLPassportNumber";
    /** PLTaxIdentificationNumber */
    KnownPiiEntityCategory["PLTaxIdentificationNumber"] = "PLTaxIdentificationNumber";
    /** PlregonNumber */
    KnownPiiEntityCategory["PlregonNumber"] = "PLREGONNumber";
    /** PTCitizenCardNumber */
    KnownPiiEntityCategory["PTCitizenCardNumber"] = "PTCitizenCardNumber";
    /** PTCitizenCardNumberV2 */
    KnownPiiEntityCategory["PTCitizenCardNumberV2"] = "PTCitizenCardNumberV2";
    /** PTTaxIdentificationNumber */
    KnownPiiEntityCategory["PTTaxIdentificationNumber"] = "PTTaxIdentificationNumber";
    /** ROPersonalNumericalCode */
    KnownPiiEntityCategory["ROPersonalNumericalCode"] = "ROPersonalNumericalCode";
    /** RUPassportNumberDomestic */
    KnownPiiEntityCategory["RUPassportNumberDomestic"] = "RUPassportNumberDomestic";
    /** RUPassportNumberInternational */
    KnownPiiEntityCategory["RUPassportNumberInternational"] = "RUPassportNumberInternational";
    /** SANationalID */
    KnownPiiEntityCategory["SANationalID"] = "SANationalID";
    /** SGNationalRegistrationIdentityCardNumber */
    KnownPiiEntityCategory["SGNationalRegistrationIdentityCardNumber"] = "SGNationalRegistrationIdentityCardNumber";
    /** SKPersonalNumber */
    KnownPiiEntityCategory["SKPersonalNumber"] = "SKPersonalNumber";
    /** SITaxIdentificationNumber */
    KnownPiiEntityCategory["SITaxIdentificationNumber"] = "SITaxIdentificationNumber";
    /** SIUniqueMasterCitizenNumber */
    KnownPiiEntityCategory["SIUniqueMasterCitizenNumber"] = "SIUniqueMasterCitizenNumber";
    /** ZAIdentificationNumber */
    KnownPiiEntityCategory["ZAIdentificationNumber"] = "ZAIdentificationNumber";
    /** KRResidentRegistrationNumber */
    KnownPiiEntityCategory["KRResidentRegistrationNumber"] = "KRResidentRegistrationNumber";
    /** Esdni */
    KnownPiiEntityCategory["Esdni"] = "ESDNI";
    /** ESSocialSecurityNumber */
    KnownPiiEntityCategory["ESSocialSecurityNumber"] = "ESSocialSecurityNumber";
    /** ESTaxIdentificationNumber */
    KnownPiiEntityCategory["ESTaxIdentificationNumber"] = "ESTaxIdentificationNumber";
    /** SQLServerConnectionString */
    KnownPiiEntityCategory["SQLServerConnectionString"] = "SQLServerConnectionString";
    /** SENationalID */
    KnownPiiEntityCategory["SENationalID"] = "SENationalID";
    /** SENationalIDV2 */
    KnownPiiEntityCategory["SENationalIDV2"] = "SENationalIDV2";
    /** SEPassportNumber */
    KnownPiiEntityCategory["SEPassportNumber"] = "SEPassportNumber";
    /** SETaxIdentificationNumber */
    KnownPiiEntityCategory["SETaxIdentificationNumber"] = "SETaxIdentificationNumber";
    /** SwiftCode */
    KnownPiiEntityCategory["SwiftCode"] = "SWIFTCode";
    /** CHSocialSecurityNumber */
    KnownPiiEntityCategory["CHSocialSecurityNumber"] = "CHSocialSecurityNumber";
    /** TWNationalID */
    KnownPiiEntityCategory["TWNationalID"] = "TWNationalID";
    /** TWPassportNumber */
    KnownPiiEntityCategory["TWPassportNumber"] = "TWPassportNumber";
    /** TWResidentCertificate */
    KnownPiiEntityCategory["TWResidentCertificate"] = "TWResidentCertificate";
    /** THPopulationIdentificationCode */
    KnownPiiEntityCategory["THPopulationIdentificationCode"] = "THPopulationIdentificationCode";
    /** TRNationalIdentificationNumber */
    KnownPiiEntityCategory["TRNationalIdentificationNumber"] = "TRNationalIdentificationNumber";
    /** UKDriversLicenseNumber */
    KnownPiiEntityCategory["UKDriversLicenseNumber"] = "UKDriversLicenseNumber";
    /** UKElectoralRollNumber */
    KnownPiiEntityCategory["UKElectoralRollNumber"] = "UKElectoralRollNumber";
    /** UKNationalHealthNumber */
    KnownPiiEntityCategory["UKNationalHealthNumber"] = "UKNationalHealthNumber";
    /** UKNationalInsuranceNumber */
    KnownPiiEntityCategory["UKNationalInsuranceNumber"] = "UKNationalInsuranceNumber";
    /** UKUniqueTaxpayerNumber */
    KnownPiiEntityCategory["UKUniqueTaxpayerNumber"] = "UKUniqueTaxpayerNumber";
    /** UsukPassportNumber */
    KnownPiiEntityCategory["UsukPassportNumber"] = "USUKPassportNumber";
    /** USBankAccountNumber */
    KnownPiiEntityCategory["USBankAccountNumber"] = "USBankAccountNumber";
    /** USDriversLicenseNumber */
    KnownPiiEntityCategory["USDriversLicenseNumber"] = "USDriversLicenseNumber";
    /** USIndividualTaxpayerIdentification */
    KnownPiiEntityCategory["USIndividualTaxpayerIdentification"] = "USIndividualTaxpayerIdentification";
    /** USSocialSecurityNumber */
    KnownPiiEntityCategory["USSocialSecurityNumber"] = "USSocialSecurityNumber";
    /** UAPassportNumberDomestic */
    KnownPiiEntityCategory["UAPassportNumberDomestic"] = "UAPassportNumberDomestic";
    /** UAPassportNumberInternational */
    KnownPiiEntityCategory["UAPassportNumberInternational"] = "UAPassportNumberInternational";
    /** Organization */
    KnownPiiEntityCategory["Organization"] = "Organization";
    /** Email */
    KnownPiiEntityCategory["Email"] = "Email";
    /** URL */
    KnownPiiEntityCategory["URL"] = "URL";
    /** Age */
    KnownPiiEntityCategory["Age"] = "Age";
    /** PhoneNumber */
    KnownPiiEntityCategory["PhoneNumber"] = "PhoneNumber";
    /** IPAddress */
    KnownPiiEntityCategory["IPAddress"] = "IPAddress";
    /** Date */
    KnownPiiEntityCategory["Date"] = "Date";
    /** Person */
    KnownPiiEntityCategory["Person"] = "Person";
    /** Address */
    KnownPiiEntityCategory["Address"] = "Address";
    /** All */
    KnownPiiEntityCategory["All"] = "All";
    /** Default */
    KnownPiiEntityCategory["Default"] = "Default";
})(exports.KnownPiiEntityCategory || (exports.KnownPiiEntityCategory = {}));
/** Known values of {@link WarningCode} that the service accepts. */
var KnownWarningCode;
(function (KnownWarningCode) {
    /** LongWordsInDocument */
    KnownWarningCode["LongWordsInDocument"] = "LongWordsInDocument";
    /** DocumentTruncated */
    KnownWarningCode["DocumentTruncated"] = "DocumentTruncated";
})(KnownWarningCode || (KnownWarningCode = {}));
/** Known values of {@link HealthcareEntityCategory} that the service accepts. */
exports.KnownHealthcareEntityCategory = void 0;
(function (KnownHealthcareEntityCategory) {
    /** BodyStructure */
    KnownHealthcareEntityCategory["BodyStructure"] = "BodyStructure";
    /** Age */
    KnownHealthcareEntityCategory["Age"] = "Age";
    /** Gender */
    KnownHealthcareEntityCategory["Gender"] = "Gender";
    /** Ethnicity */
    KnownHealthcareEntityCategory["Ethnicity"] = "Ethnicity";
    /** ExaminationName */
    KnownHealthcareEntityCategory["ExaminationName"] = "ExaminationName";
    /** Date */
    KnownHealthcareEntityCategory["Date"] = "Date";
    /** Direction */
    KnownHealthcareEntityCategory["Direction"] = "Direction";
    /** Frequency */
    KnownHealthcareEntityCategory["Frequency"] = "Frequency";
    /** MeasurementValue */
    KnownHealthcareEntityCategory["MeasurementValue"] = "MeasurementValue";
    /** MeasurementUnit */
    KnownHealthcareEntityCategory["MeasurementUnit"] = "MeasurementUnit";
    /** RelationalOperator */
    KnownHealthcareEntityCategory["RelationalOperator"] = "RelationalOperator";
    /** Time */
    KnownHealthcareEntityCategory["Time"] = "Time";
    /** Course */
    KnownHealthcareEntityCategory["Course"] = "Course";
    /** GeneOrProtein */
    KnownHealthcareEntityCategory["GeneOrProtein"] = "GeneOrProtein";
    /** Variant */
    KnownHealthcareEntityCategory["Variant"] = "Variant";
    /** Expression */
    KnownHealthcareEntityCategory["Expression"] = "Expression";
    /** MutationType */
    KnownHealthcareEntityCategory["MutationType"] = "MutationType";
    /** AdministrativeEvent */
    KnownHealthcareEntityCategory["AdministrativeEvent"] = "AdministrativeEvent";
    /** CareEnvironment */
    KnownHealthcareEntityCategory["CareEnvironment"] = "CareEnvironment";
    /** HealthcareProfession */
    KnownHealthcareEntityCategory["HealthcareProfession"] = "HealthcareProfession";
    /** Diagnosis */
    KnownHealthcareEntityCategory["Diagnosis"] = "Diagnosis";
    /** SymptomOrSign */
    KnownHealthcareEntityCategory["SymptomOrSign"] = "SymptomOrSign";
    /** ConditionQualifier */
    KnownHealthcareEntityCategory["ConditionQualifier"] = "ConditionQualifier";
    /** ConditionScale */
    KnownHealthcareEntityCategory["ConditionScale"] = "ConditionScale";
    /** MedicationClass */
    KnownHealthcareEntityCategory["MedicationClass"] = "MedicationClass";
    /** MedicationName */
    KnownHealthcareEntityCategory["MedicationName"] = "MedicationName";
    /** Dosage */
    KnownHealthcareEntityCategory["Dosage"] = "Dosage";
    /** MedicationForm */
    KnownHealthcareEntityCategory["MedicationForm"] = "MedicationForm";
    /** MedicationRoute */
    KnownHealthcareEntityCategory["MedicationRoute"] = "MedicationRoute";
    /** FamilyRelation */
    KnownHealthcareEntityCategory["FamilyRelation"] = "FamilyRelation";
    /** TreatmentName */
    KnownHealthcareEntityCategory["TreatmentName"] = "TreatmentName";
    /** Allergen */
    KnownHealthcareEntityCategory["Allergen"] = "Allergen";
    /** Employment */
    KnownHealthcareEntityCategory["Employment"] = "Employment";
    /** LivingStatus */
    KnownHealthcareEntityCategory["LivingStatus"] = "LivingStatus";
    /** SubstanceUse */
    KnownHealthcareEntityCategory["SubstanceUse"] = "SubstanceUse";
    /** SubstanceUseAmount */
    KnownHealthcareEntityCategory["SubstanceUseAmount"] = "SubstanceUseAmount";
})(exports.KnownHealthcareEntityCategory || (exports.KnownHealthcareEntityCategory = {}));
/** Known values of {@link RelationType} that the service accepts. */
exports.KnownRelationType = void 0;
(function (KnownRelationType) {
    /** Abbreviation */
    KnownRelationType["Abbreviation"] = "Abbreviation";
    /** BodySiteOfCondition */
    KnownRelationType["BodySiteOfCondition"] = "BodySiteOfCondition";
    /** BodySiteOfTreatment */
    KnownRelationType["BodySiteOfTreatment"] = "BodySiteOfTreatment";
    /** CourseOfCondition */
    KnownRelationType["CourseOfCondition"] = "CourseOfCondition";
    /** CourseOfExamination */
    KnownRelationType["CourseOfExamination"] = "CourseOfExamination";
    /** CourseOfMedication */
    KnownRelationType["CourseOfMedication"] = "CourseOfMedication";
    /** CourseOfTreatment */
    KnownRelationType["CourseOfTreatment"] = "CourseOfTreatment";
    /** DirectionOfBodyStructure */
    KnownRelationType["DirectionOfBodyStructure"] = "DirectionOfBodyStructure";
    /** DirectionOfCondition */
    KnownRelationType["DirectionOfCondition"] = "DirectionOfCondition";
    /** DirectionOfExamination */
    KnownRelationType["DirectionOfExamination"] = "DirectionOfExamination";
    /** DirectionOfTreatment */
    KnownRelationType["DirectionOfTreatment"] = "DirectionOfTreatment";
    /** DosageOfMedication */
    KnownRelationType["DosageOfMedication"] = "DosageOfMedication";
    /** ExaminationFindsCondition */
    KnownRelationType["ExaminationFindsCondition"] = "ExaminationFindsCondition";
    /** ExpressionOfGene */
    KnownRelationType["ExpressionOfGene"] = "ExpressionOfGene";
    /** ExpressionOfVariant */
    KnownRelationType["ExpressionOfVariant"] = "ExpressionOfVariant";
    /** FormOfMedication */
    KnownRelationType["FormOfMedication"] = "FormOfMedication";
    /** FrequencyOfCondition */
    KnownRelationType["FrequencyOfCondition"] = "FrequencyOfCondition";
    /** FrequencyOfMedication */
    KnownRelationType["FrequencyOfMedication"] = "FrequencyOfMedication";
    /** FrequencyOfTreatment */
    KnownRelationType["FrequencyOfTreatment"] = "FrequencyOfTreatment";
    /** MutationTypeOfGene */
    KnownRelationType["MutationTypeOfGene"] = "MutationTypeOfGene";
    /** MutationTypeOfVariant */
    KnownRelationType["MutationTypeOfVariant"] = "MutationTypeOfVariant";
    /** QualifierOfCondition */
    KnownRelationType["QualifierOfCondition"] = "QualifierOfCondition";
    /** RelationOfExamination */
    KnownRelationType["RelationOfExamination"] = "RelationOfExamination";
    /** RouteOfMedication */
    KnownRelationType["RouteOfMedication"] = "RouteOfMedication";
    /** ScaleOfCondition */
    KnownRelationType["ScaleOfCondition"] = "ScaleOfCondition";
    /** TimeOfCondition */
    KnownRelationType["TimeOfCondition"] = "TimeOfCondition";
    /** TimeOfEvent */
    KnownRelationType["TimeOfEvent"] = "TimeOfEvent";
    /** TimeOfExamination */
    KnownRelationType["TimeOfExamination"] = "TimeOfExamination";
    /** TimeOfMedication */
    KnownRelationType["TimeOfMedication"] = "TimeOfMedication";
    /** TimeOfTreatment */
    KnownRelationType["TimeOfTreatment"] = "TimeOfTreatment";
    /** UnitOfCondition */
    KnownRelationType["UnitOfCondition"] = "UnitOfCondition";
    /** UnitOfExamination */
    KnownRelationType["UnitOfExamination"] = "UnitOfExamination";
    /** ValueOfCondition */
    KnownRelationType["ValueOfCondition"] = "ValueOfCondition";
    /** ValueOfExamination */
    KnownRelationType["ValueOfExamination"] = "ValueOfExamination";
    /** VariantOfGene */
    KnownRelationType["VariantOfGene"] = "VariantOfGene";
})(exports.KnownRelationType || (exports.KnownRelationType = {}));
/** Known values of {@link ExtractiveSummarizationOrderingCriteria} that the service accepts. */
exports.KnownExtractiveSummarizationOrderingCriteria = void 0;
(function (KnownExtractiveSummarizationOrderingCriteria) {
    /** Indicates that results should be sorted in order of appearance in the text. */
    KnownExtractiveSummarizationOrderingCriteria["Offset"] = "Offset";
    /** Indicates that results should be sorted in order of importance (i.e. rank score) according to the model. */
    KnownExtractiveSummarizationOrderingCriteria["Rank"] = "Rank";
})(exports.KnownExtractiveSummarizationOrderingCriteria || (exports.KnownExtractiveSummarizationOrderingCriteria = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Type of actions supported by the {@link TextAnalysisClient.analyze} method.
 */
const AnalyzeActionNames = {
    EntityLinking: "EntityLinking",
    EntityRecognition: "EntityRecognition",
    KeyPhraseExtraction: "KeyPhraseExtraction",
    PiiEntityRecognition: "PiiEntityRecognition",
    LanguageDetection: "LanguageDetection",
    SentimentAnalysis: "SentimentAnalysis",
};
/**
 * Type of actions supported by the {@link TextAnalysisClient.beginAnalyzeBatch} method.
 */
const AnalyzeBatchActionNames = {
    SentimentAnalysis: "SentimentAnalysis",
    EntityRecognition: "EntityRecognition",
    PiiEntityRecognition: "PiiEntityRecognition",
    KeyPhraseExtraction: "KeyPhraseExtraction",
    EntityLinking: "EntityLinking",
    Healthcare: "Healthcare",
    ExtractiveSummarization: "ExtractiveSummarization",
    AbstractiveSummarization: "AbstractiveSummarization",
    CustomEntityRecognition: "CustomEntityRecognition",
    CustomSingleLabelClassification: "CustomSingleLabelClassification",
    CustomMultiLabelClassification: "CustomMultiLabelClassification",
};
/**
 * Enum of possible error codes of a {@link TextAnalysisError}.
 */
const KnownTextAnalysisErrorCode = Object.assign(Object.assign({}, exports.KnownErrorCode), exports.KnownInnerErrorCode);

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.AnalyzeActionNames = AnalyzeActionNames;
exports.AnalyzeBatchActionNames = AnalyzeBatchActionNames;
exports.KnownTextAnalysisErrorCode = KnownTextAnalysisErrorCode;
exports.TextAnalysisClient = TextAnalysisClient;
//# sourceMappingURL=index.js.map
